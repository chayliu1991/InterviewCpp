# 启动线程

每个程序都至少有一个线程，即 `main` 函数所在的线程，称之为主线程。

将函数添加为 std::thread  的参数即可启动线程：

```
#include <thread>
#include <iostream>

void f()
{
    std::cout << "hello world";
}

int main()
{
    std::thread t(f);
    t.join();
}
```

std::thread 的参数也可以是函数对象或者 lambda 表达式：

```
struct ThreadFunctor
{
	void operator()()
	{
		std::cout << "ThreadFunctor() called" << std::endl;
	}
};

void thread_func()
{
	std::cout << "thread_func called" << std::endl;
}


int main()
{
	//@ 使用仿函数对象作为线程函数
	ThreadFunctor tf;
	std::thread t1(tf); //@ OK
	//@ std::thread t(ThreadFunctor()); //@ most vexing parse，ThreadFunctor()被视为函数声明
	//@ 解决 most vexing parse的方法:
	std::thread t2((ThreadFunctor())); //@ OK
	std::thread t3{ ThreadFunctor() }; //@ OK
	
	//@ 使用 lambda
	std::thread t4([] {std::cout << "lambda called" << std::endl; });

	//@ 使用 std::bind 绑定的函数
	std::thread t5(std::bind(thread_func));

	t1.join();
	t2.join();
	t3.join();
	t4.join();
	t5.join();

	return 0;
}
```

## 线程函数传参

创建线程时，在线程函数后面依次传参：

```
void thread_func(int i, float f)
{
	std::cout << "thread_func called: " << i << " " << f << std::endl;
}

int main()
{
	//@ 线程函数传参
	std::thread t(thread_func, 1, 3.124);
	t.join();

	return 0;
}
```

被调用函数有默认参数依然需要指定参数，并且将会忽略默认参数：

```
void thread_func(int i = 100, float f = 9.90)
{
	std::cout << "thread_func called: " << i << " " << f << std::endl;
}

int main()
{
	//std::thread t1(thread_func); //@ 错误，未指定参数
	std::thread t2(thread_func,2,0.98);  //@ 将会忽略默认参数

	t2.join();

	return 0;
}
```

按引用传参需要显示指定：

```
void func(int& n) 
{ 
	++n; 
}

int main()
{
	int i = 1;
	//@ 显式指定按引用传参
	std::thread t2(func, std::ref(i));
	t2.join();
	std::cout << i << "\n"; //@ 2
}
```

类成员函数作为线程函数的传参：

```
class Test
{
public:
	void f(int i) { std::cout << i << std::endl; }
};

int main()
{
	Test test;

	//@ 第一个参数为成员函数地址，第二个参数为实例地址，之后为函数参数
	std::thread t(&Test::f, &test, 42);
	t.join();
}
```

如果参数是 move only 类型，需要移动传参：

```
void f(std::unique_ptr<int> p)
{
	std::cout << *p << std::endl;
}

int main()
{
	std::unique_ptr<int> p(new int(42));
	//std::thread t(f, p); //@ 错误
	std::thread t(f, std::move(p)); //@ 错误

	t.join();
}
```

## 线程只能移动

一个线程不能重复被关联：

```
std::thread t1(f);
std::thread t2 = std::move(t1); //@ t1所有权给t2，t2关联执行f的线程

t1 = std::thread(f); //@ t1重新关联一个执行g的线程

std::thread t3;
t3 = std::move(t2); //@ t3关联t2的线程，t2无关联
t1 = std::move(t3); //@ t1已有关联g的线程，调用std::terminate终止程序
```

# 线程管理

启动线程后在线程销毁前要对其调用 join 或detach，否则 std::thread 的析构函数会调用 std::terminate 终止程序。

## detach

detach 是让目标线程成为守护线程（daemon threads）。

- 一旦 detach，目标线程将独立执行，即便其对应的 thread 对象销毁也不影响线程的执行
- 一旦 detach，主调线程无法再取得该子线程的控制权。子线程将被 C++ 运行时库接管，当该线程执行结束的时候，由 C++ 运行时库负责回收该线程的资源

## join

- join 之后，当前线程会一直阻塞，直到目标线程执行完成

- join 之后，当子线程执行结束，主调线程将回收子调线程资源，并继续运行

如果目标线程的任务非常耗时，就要考虑好是否需要在主线程上等待它了，因为这很可能会导致主线程卡住。

## joinable

每个 std::thread 对象都处于可合并（joinable）或不可合并（unjoinable）的状态。joinable 可以用来判断这个线程当前是否可以被 join。

一个可合并的 std::thread 对应于一个底层异步运行的线程，若底层线程处于阻塞、等待调度或已运行结束的状态。不可合并的情况：

- 默认构造的 std::thread：此时没有要运行的函数，因此没有对应的底层运行线程
- 已移动的 std::thread：移动操作导致底层线程被转用于另一个 std::thread  对象
- 已经 detach 和 join 过的 std::thread

std::thread RAII 类：

```
class ScopeThread
{
public:
	enum class Action { Join, Detach };

	ScopeThread(std::thread & t, Action act = Action::Join) : t_(std::move(t)), action_(act)
	{
		if (!t.joinable())
		{
			throw std::logic_error("init thread can not join");
		}
	}

	~ScopeThread()
	{
		if (action_ == Action::Join)
			t_.join();
		else
			t_.detach();
	}

	ScopeThread(ScopeThread&&) = default;
	ScopeThread& operator = (ScopeThread&&) = default;

	std::thread& get() { return t_; }
private:
	Action action_;
	std::thread t_;
};
```

如果线程运行过程中发生异常，之后调用的 join 会被忽略，为此需要捕获异常并在处理异常时调用 join：

```
void f()
{
    int x = 0;
    A a(x);
    std::thread t(a);
    try
    {
        doSomethingHere();  //@ 可能发生异常
    }
    catch(...)
    {
        t.join();  //@ 发生异常时候要调用 join，释放线程资源
        throw;
    }
    t.join();
}
```

# 其它

## 获取硬件支持并发数

多核系统中，返回值可以是 CPU 核芯的数量。返回值也仅仅是一个提示，当系统信息无法获取时，函数也会返回0。

```
int main() 
{
	unsigned int n = std::thread::hardware_concurrency();
	std::cout << n << " concurrent threads are supported.\n";
}
```

## 线程标识

线程 id 允许拷贝和比较，因此可以将其作为容器的键值。如果两个线程 id 相等，则两者是同一线程或都无线程。

```
std::thread::id masterThread; //@ 主线程

void f()
{
    if (std::this_thread::get_id() == masterThread)
    { //@ 主线程要做一些额外工作，即可通过比较线程id来确认主线程
        doMasterThreadWork();
    }
    doCommonWork();
}
```

## 交换两个线程

```
void foo()
{
	std::this_thread::sleep_for(std::chrono::seconds(1));
}

void bar()
{
	std::this_thread::sleep_for(std::chrono::seconds(1));
}

int main()
{
	std::thread t1(foo);
	std::thread t2(bar);

	std::cout << "thread 1 id: " << t1.get_id() << '\n'
		<< "thread 2 id: " << t2.get_id() << '\n';

	std::swap(t1, t2);

	std::cout << "after std::swap(t1, t2):" << '\n'
		<< "thread 1 id: " << t1.get_id() << '\n'
		<< "thread 2 id: " << t2.get_id() << '\n';


	t1.join();
	t2.join();

	return 0;
}
```

## 放弃执行

```
std::this_thread::yield();
```

目的是避免一个线程频繁与其他线程争抢CPU时间片, 从而导致多线程处理性能下降。让当前线程让渡出自己的CPU时间片(给其他线程使用)。

## 休眠

```
std::this_thread::sleep_for();
```

让当前线程休眠指定的一段时间。

