# race  condition

如果共享数据是只读的，那么只读操作不会影响到数据，更不会涉及对数据的修改，所以所有线程都会获得同样的数据。但是，当一个或多个线程要修改共享数据时，就会产生很多麻烦。

线程修改共享数据时，就会发生破坏不变量的情况，此时如果有其他线程访问，就可能导致不变量被永久性破坏，这就是 race condition。

如果线程执行顺序的先后对结果无影响，则为不需要关心的良性竞争。需要关心的是不变量被破坏时产生的 race condition。

C++标准中定义了data race的概念，指代一种特定的 race condition，即并发修改单个对象。data race 会造成未定义行为。

解决办法：

- 对数据结构采用某种保护机制，确保只有进行修改的线程才能看到不变量被破坏时的中间状态。从其他访问线程的角度来看，修改不是已经完成了，就是还没开始
- 对数据结构和不变量的设计进行修改，修改完的结构必须能完成一系列不可分割的变化，也就是保证每个不变量保持稳定的状态，这就是所谓的无锁编程
- 使用事务的方式去处理数据结构的更新。所需的一些数据和读取都存储在事务日志中，然后将之前的操作合为一步，再进行提交。当数据结构被另一个线程修改后，或处理已经重启的情况下，提交就会无法进行，这称作为“软件事务内存”

# 使用互斥量保护数据

使用 mutex 在访问共享数据前加锁，访问结束后解锁。一个线程用特定的 mutex 锁定后，其他线程必须等待该线程的 mutex 解锁才能访问共享数据。

C++ 11 中提供了如下 4 种语义的互斥量：

- std::mutex：独占的互斥量，不能递归使用
- std::timed_mutex：带超时的独占的互斥量，不能递归使用
- std::recursive_mutex：递归互斥量，不带超时功能
- std::recursive_timed_mutex：带超时的递归互斥量

## std::mutex

std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性，即不支持递归地对 std::mutex 对象上锁。

- std::mutex不允许拷贝构造，也不允许移动拷贝，最初产生的 mutex 对象是处于 unlocked 状态的
-  std::mutex::lock  调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：
  - 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock 之前，该线程一直拥有该锁
  - 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住
  - 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)

- std::mutex::unlock()， 解锁，释放对互斥量的所有权
- try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况：
  - 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量
  - 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉
  - 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)

```
std::mutex g_lock;
void func()
{
	g_lock.lock();
	std::cout << "enter:  " << std::this_thread::get_id() << std::endl;
	std::this_thread::sleep_for(std::chrono::microseconds(1));
	std::cout << "leave: " << std::this_thread::get_id() << std::endl;
	g_lock.unlock();
}

int main()
{
	std::vector<std::thread> threads;
	for (int i = 0; i < 3; i++)
	{
		threads.emplace_back(func);
	}

	std::for_each(threads.begin(), threads.end(), std::mem_fn(&std::thread::join));

	return 0;
}
```

## std::recursive_mutex

和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。

```
struct Complex
{
	std::recursive_mutex mutex_;
	int i;

	Complex() :i(0) {}

	void mul(int x)
	{
		std::lock_guard<std::recursive_mutex> lock(mutex_);
		i *= x;
	}

	void div(int x)
	{
		std::lock_guard<std::recursive_mutex> lock(mutex_);
		i /= x;
	}

	void both(int x, int y)
	{
		std::lock_guard<std::recursive_mutex> lock(mutex_);
		mul(x);
		div(x);
	}
};

int main()
{
	Complex complex;
	complex.both(32, 23);
	//@ 同一线程可以多次获取同一互斥量，不会发生死锁

	return 0;
}
```

但是不提倡使用 std::recrusive_mutex：

- 需要用到递归锁的多线程互斥处理往往本身就是可以简化的，允许递归互斥很容易放纵复杂逻辑的产生，从而导致一些多线程同步引起的晦涩问题
- 递归锁比起非递归锁，效率会低一点
- 递归锁虽然允许同一线程多次获得同一个互斥量，可重复获得的最大次数并未具体说明，一旦超过一定次数，再对 lock 进行调用就会抛出 std::system 错误

## std::time_mutex

std::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()：

- try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false
- try_lock_until 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false

```
std::timed_mutex mtx;

void func() {
	// waiting to get a lock: each thread prints "-" every 200ms:
	while (!mtx.try_lock_for(std::chrono::milliseconds(200))) {
		std::cout << "-";
	}
	// got a lock! - wait for 1s, then this thread prints "*"
	std::this_thread::sleep_for(std::chrono::milliseconds(1000));
	std::cout << "*\n";
	mtx.unlock();
}

int main()
{
	std::vector<std::thread> threads;
	for (int i = 0; i < 5; i++)
	{
		threads.emplace_back(func);
	}
		
	std::for_each(threads.begin(), threads.end(), std::mem_fn(&std::thread::join));
	return 0;
}
```

## std::recursive_timed_mutex

std::recursive_timed_mutex 结合了 std::recursive_mutex 和 std::time_mutex 的功能。

# 上锁

## 上锁策略

std::defer_lock 、 std::try_to_lock 和 std::adopt_lock 分别是空结构体标签类型 std::defer_lock_t 、 std::try_to_lock_t 和 std::adopt_lock_t 的实例。

它们用于为 std::lock_guard 、 std::unique_lock 及 std::shared_lock 指定锁定策略：

- defer_lock_t：不获得互斥量的所有权
- try_to_lock_t：尝试以非阻塞方式获得互斥量的所有权
- adopt_lock_t：假设调用方线程已拥有互斥量的所有权

## std::lock

std::lock 可以一次性锁住多个 mutex，并且没有死锁风险。std::lock 可能抛异常，此时就不会上锁，因此 std::lock 保证要么都锁住，要么都不锁。

```
struct bank_account {
	explicit bank_account(int balance) : balance(balance) {}
	int balance;
	std::mutex m;
};

void transfer(bank_account &from, bank_account &to, int amount)
{
	// 锁定两个互斥而不死锁
	std::lock(from.m, to.m);
	// 保证二个已锁定互斥在作用域结尾解锁
	std::lock_guard<std::mutex> lock1(from.m, std::adopt_lock);
	std::lock_guard<std::mutex> lock2(to.m, std::adopt_lock);

	// 等价方法：
	//    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);
	//    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);
	//    std::lock(lock1, lock2);

	from.balance -= amount;
	to.balance += amount;
}

int main()
{
	bank_account my_account(100);
	bank_account your_account(50);

	std::thread t1(transfer, std::ref(my_account), std::ref(your_account), 10);
	std::thread t2(transfer, std::ref(your_account), std::ref(my_account), 5);

	t1.join();
	t2.join();

	std::cout << "my balance:" << my_account.balance << std::endl;
	std::cout << "your balance:" << your_account.balance << std::endl;
	
	return 0;
}
```

##　std::lock_guard 

 std::lock_guard 是 std::mutex RAII 实现，便线程对互斥量上锁：

```
std::mutex g_lock;
void func()
{
	std::lock_guard<std::mutex> locker(g_lock);
	std::cout << "enter:  " << std::this_thread::get_id() << std::endl;
	std::this_thread::sleep_for(std::chrono::microseconds(1));
	std::cout << "leave: " << std::this_thread::get_id() << std::endl;
}
```

## std::unique_lock

std::unique_lock 更加灵活：

- 可以指定参数 std::defer_lock  表示 mutex 应保持解锁状态，以使 mutex 能被 std::unique_lock::lock 获取
- 可以把 std::unique_lock 传给std::lock
- std::unique_lock 比 std::lock_guard 占用的空间多，会稍慢一点，如果不需要更灵活的锁，依然可以使用 std::lock_guard

```
std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);
std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);
//@ std::defer_lock 表示不获取m的所有权，因此m还未上锁
std::lock(lock1, lock2); //@ 此处上锁
```

对一些费时的操作（如文件IO）上锁可能造成很多操作被阻塞，可以在面对这些操作时先解锁：

```
void f()
{
    std::unique_lock<std::mutex> l(m);
    auto data = getData();
    l.unlock(); //@ 费时操作没有必要持有锁，先解锁
    auto res = process(data);
    l.lock(); //@ 为了写入数据再次上锁
    writeResult(data, res);
}
```

##  std::scoped_lock

C++17 提供了加强版的 std::scoped_lock，它可以接受任意数量的 std::mutex，可完全取代 std::lock_guard：

```
std::scoped_lock g(m1, m2);
```

## 死锁

- 死锁的四个必要条件：
  - 互斥
  - 占有且等待
  - 不可抢占
  - 循环等待

避免死锁通常建议让两个 mutex 以相同顺序上锁，总是先锁A再锁B，但这并不适用所有情况。

### 避免死锁的建议

- 建议1：一个线程已经获取一个锁时就不要获取第二个。如果每个线程只有一个锁，锁上就不会产生死锁（但除了互斥锁，其他方面也可能造成死锁，比如即使无锁，线程间相互等待(互相 join)也可能造成死锁）
- 建议2：持有锁时避免调用用户提供的代码。用户提供的代码可能做任何事，包括获取锁，如果持有锁时调用用户代码获取锁，就会违反第一个建议，并造成死锁。但有时调用用户代码是无法避免
- 建议3：按固定顺序获取锁。如果必须获取多个锁且不能用 std::lock 同时获取，最好在每个线程上用固定顺序获取
- 建议4：如果一个锁被低层持有，就不允许再上锁

### 层次锁

```
class HierarchicalMutex
{
	std::mutex internal_mutex;

	unsigned long const hirearchy_value;
	unsigned long previous_hirearchy_value;
	//@ thread_local 的值来代表当前线程的层级值
	static thread_local unsigned long this_thread_hierarchy_value;

	void check_for_hierarchy_violation()
	{
		if (this_thread_hierarchy_value < hirearchy_value)
		{
			throw std::logic_error("mutex hierachy violated");
		}
	}

	void update_hierarchy_value()
	{
		//@ 先存储当前线程的层级值（用于解锁时恢复）
		previous_hirearchy_value = this_thread_hierarchy_value;
		this_thread_hierarchy_value = hirearchy_value;
	}
public:
	explicit HierarchicalMutex(unsigned long value) :
		hirearchy_value(value),
		previous_hirearchy_value(0)
	{}

	void lock()
	{
		check_for_hierarchy_violation(); //@ 要求线程层级值大于锁的层级值
		internal_mutex.lock();
		update_hierarchy_value();
	}

	void unlock()
	{
		this_thread_hierarchy_value = previous_hirearchy_value;
		internal_mutex.unlock();
	}

	bool try_lock()
	{
		check_for_hierarchy_violation();
		if (!internal_mutex.try_lock())
			return false;
		update_hierarchy_value();
		return true;
	}
};


//@ this_thread_hierarchy_value 被初始化为最大值，所以最初所有线程都能被锁住。
//@ 因为其声明中有 thread_local，所以每个线程都有其拷贝副本
//@ 这样线程中变量状态完全独立，当从另一个线程进行读取时，变量的状态也完全独立。
thread_local unsigned long
HierarchicalMutex::this_thread_hierarchy_value(ULONG_MAX);



//@ 应用示例
HierarchicalMutex high(10000);
HierarchicalMutex mid(6000);
HierarchicalMutex low(5000);


void lf() //@ 最低层函数
{
	std::scoped_lock l(low);
}

void hf()
{
	std::scoped_lock l(high);
	lf();  //@ 可以调用低层函数
}

void mf()
{
	std::scoped_lock l(mid);
	hf(); //@ 中层调用了高层函数，违反了层次结构
}
```

# 其他保护共享数据的方式

## call_once

双重检查锁模式的缺陷：

```
void f()
{
    if (!p) 
    {
        std::scoped_lock l(m);
        if (!p)
        {
            p.reset(new A);
        }
    }
    p->doSomething();
}
```

第一次的检查没上锁，可能与其他线程中被保护的 reset 操作产生竞争。如果当前线程看见其他线程写入了指针，但没看到新创建的对象实例，调用 doSomething 就会出错：

```
p.reset(new A);
```

正常的执行步骤：

1. 为 A 对象分配一片内存

2. 在分配的内存上调用 A 的构造函数，构造一个A对象

3. 返回该内存的指针，让 p 指向该内存

但是，编译器并不是一定按照上面的顺序执行，有可能是3->2。

为了处理 race condition，C++标准库提供了 std::once_flag 和 std::call_once：

```
std::shared_ptr<A> p;
std::once_flag flag;

void init()
{
    p.reset(new A);
}

void f()
{
    std::call_once(flag, init);
    p->doSomething();
}
```

每个线程只要使用 std::call_once，在 std::call_once 结束时就能安全地知道指针已被其他线程初始化，而且这比使用 mutex 的开销更小。

## static 变量

static 变量的初始化存在潜在的 race condition：变量声明为 static 时，声明后就完成了初始化，一个线程完成了初始化，其他线程仍会抢着定义这个变量。

为此，C++11规定 static 变量的初始化只完全发生在一个线程中，直到初始化完成前其他线程都不会做处理，从而避免了 race condition。只有一个全局实例时可以不使用 std::call_once 而直接用 static 变量：

```
class A {
public:
    static A& getInstance();
    A(const A&) = delete;
    A& operator(const A&) = delete;
private:
    A() = default;
    ~A() = default;
};

A& A::getInstance()
{
    static A instance; //@ 线程安全的初始化
    return instance;
}
```

## 读写锁

有些数据（比如缓存中存放的 DNS 入口表）需要经常访问但更新频率很低，如果用 std::mutex 保护数据有些过度（大量读的操作也会因锁而影响性能），这就需要用上读写锁（reader-writer mutex），它允许多个线程并发读但仅一个线程写。

- C++17 提供了 std::shared_mutex 和 std::shared_timed_mutex（C++14），后者比前者提供了更多操作，但前者性能更高。C++11没有提供读写锁，为此可使用 boost::shared_mutex
- C++14 提供了 std::shared_lock，用法和  std::unique_lock 相同，此外 std::shared_lock 还允许多线程同时获取共享锁，因此一般用std::shared_lock] 锁定读，std::unique_lock 锁定写
- 读写锁并不是万能的，其性能与处理器数量及读写线程的负载有关

```
class A {
private:
    mutable std::shared_mutex m;
    int n = 0;
public:
    int read()
    {
        std::shared_lock<std::shared_mutex> l(m);
        return n;
    }
    void write()
    {
        std::unique_lock<std::shared_mutex> l(m);
        ++n;
    }
};
```

## 递归锁

一个线程已经获取 std::mutex（即已上锁）后再次上锁就会产生未定义行为：

```
std::mutex m;

void f()
{
    m.lock();
    m.unlock();
}

void g()
{
    m.lock();
    f();
    m.unlock();
}

int main()
{
    std::thread t(g);
    t.join(); //@ 产生未定义行为
}
```

为了允许这种情况，C++ 提供了 std::recursive_mutex，它可以在一个线程上多次获取锁，但在其他线程获取锁之前必须释放所有的锁。

多数情况下如果需要递归锁，说明代码设计存在问题。比如一个类的每个成员函数都会上锁，一个成员函数调用另一个成员函数，就可能多次上锁，这种情况用递归锁就可以避免产生未定义行为。但显然这个设计本身是有问题的，更好的办法是提取其中一个函数作为 private  成员并且不上锁，其他成员先上锁再调用该函数。

