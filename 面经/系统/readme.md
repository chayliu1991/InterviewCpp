# 进程的通信方式有哪些
管道：简单，只能在父子进程间单向传输，效率低下。

消息队列：容量受到系统限制，发送消息（拷贝）需要花很多时间读内存，不适合频繁通信。

共享内存：能够很容易控制容量，速度快，但要解决多进程竞争内存问题。

信号量：信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。

套接字：不仅可以用于本地进程通信，还可以用于不同主机进程之间的通信。

# 消息队列的实现
消息队列是一种异步的服务间通信方式，是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。

消息队列的实现：

```
#include <sys/msg.h>
// 创建或打开消息队列：成功返回队列ID，失败返回-1
int msgget(key_t key, int flag);
// 添加消息：成功返回0，失败返回-1
int msgsnd(int msqid, const void *ptr, size_t size, int flag);
// 读取消息：成功返回消息数据的长度，失败返回-1
int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
// 控制消息队列：成功返回0，失败返回-1
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

# 内核态和用户态
内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。

用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。

为什么要有内核态和用户态：由于需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据， 或者获取外围设备的数据，并发送到网络，造成安全问题。

用户态和内核态的三种切换方式：

（1）系统调用：用户进程通过系统调用申请使用操作系统提供的服务程序来完成工作，比如read()、fork()等。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现的，例如Linux的int 80h中断。

（2）异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

（3）中断：当外围设备完成用户请求的操作后，会向CPU发送中断信号。这时CPU会暂停执行下一条指令（用户态）转而执行与该中断信号对应的中断处理程序（内核态）




