# 基本函数

现代 C++ 中一共有 6 个基本函数：

- 默认构造函数，拷贝构造函数，移动构造函数
- 赋值函数，移动赋值函数
- 析构函数

默认行为：

- 如果基类中声明虚析构函数，则默认生成一个虚析构函数，否则生成的函数是非虚函数
- 拷贝构造函数和拷贝赋值运算符，默认执行的是浅拷贝

但是需要注意：

- 若用户定义了任何构造函数，编译器将不再生成默认构造函数
- 没有初始化的非静态 const 数据成员和引用类型数据成员会导致默认提供的默认构造函数被删除
- 非静态的 const 数据成员和引用类型数据成员会导致默认提供的拷贝构造函数、拷贝赋值函数、移动构造函数和移动赋值函数被删除  
- 用户如果自己声明了一个移动构造函数或移动赋值函数，则默认提供的拷贝构造函数和拷贝赋值函数被删除  
- 用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数  
- 用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动构造函数和析构函数，编译器会隐式声明一个移动赋值函数  

"default" 可以强制编译器提供某个函数的默认实现，"delete" 可以强制编译器删除某个函数的实现：

```
struct Test final
{
	Test() = default;
	Test(const Test& t) = delete;
};
```

# 隐式类型转换

"explicit"  关键字可以防止类隐式类型转换：

```
struct Test
{
	explicit Test(int i)  //@ 显式单参构造
	{
	}
	
	explicit operator bool() //@ 显式转换为 bool 类型
	{}
};
```

# 类内初始化

在 C++11 里，你可以在类里声明变量的同时给它赋值，实现初始化，这样不但简单清晰，也消除了隐患。  

```
struct Test final
{
public:
	Test(int a) : i(a) //@ 可以单独初始化某个数据成员
	{
	}

	Test() = default;  //@ 需要默认构造函数
	~Test() = default; //@ 需要默认析构函数

private:
	int i = 10;
	std::string s{"hello"};
	std::vector<int> v{ 1,2,3 };
};
```

# 类型别名

C++11 扩展了关键字 using 的用法，增加了 typedef 的能力，可以定义类型别名。  

```
struct Test final
{
public:
	using VecI = std::vector<int>;
};
```

# 委托构造

C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：

```
struct Test final
{
public:
	Test(int a) : i(a)
	{
	}

	Test() : Test(0)
	{
	}

	Test(const std::string& s) : i(std::stoi(s))
	{
	}
private:
	int i;
};
```

# 继承构造

在传统 C++ 中，构造函数如果需要继承是需要将参数传递的，这将导致效率低下。C++11 利用关键字 using 引入了继承构造函数的概念：

```
class Base 
{
public:
	int value1;
	int value2;
	Base() {
		value1 = 1;
	}

	Base(int value) : Base()  //@ 委托 Base() 构造函数
	{
		value2 = value;
	}
};

class Derived final : public Base
{
public:
	using Base::Base; //@ 继承构造
};

int main() {
	Derived d(3);
	std::cout << d.value1 << std::endl;
	std::cout << d.value2 << std::endl;
}
```

# 显式虚函数重载

在传统 C++中，经常容易发生意外重载虚函数的事情。例如：

```cpp
struct Base
{
	virtual void foo(int);
};

struct Derived : Base
{
	void foo(int);
};
```

`SubClass::foo` 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。

C++11 引入了 `override` 和 `final` 这两个关键字来防止上述情形的发生。

```
struct Base
{
	virtual void foo(int);
};

struct Derived : Base
{
	virtual void foo(int) override;
	virtual void foo(float) override; //@ 非法，父类没有此虚函数
};
```

```
struct A
{
	virtual void foo(int) final;
};

struct B final : A
{
}; //@ OK

struct C : B
{
}; //@ 非法，class B 已经是 final

struct D  : A
{
	virtual void foo(int); //@ 非法
}; //@ OK
```

# 强类型枚举

C++11 引入了枚举类，并使用 enum class 的语法进行声明：

```
enum class new_enum : unsigned int {
    value1,
    value2,
    value3 = 100,
    value4 = 100
};
```

这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较，更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较：

```
if (new_enum::value3 == new_enum::value4) {
    // 会输出
    std::cout << "new_enum::value3 == new_enum::value4" << std::endl;
}
```

枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 int）。

枚举值输出：

```
template <typename T>
std::ostream& operator << (typename std::enable_if<std::is_enum<T>::value, std::ostream>::type& stream, const T& e)
{
	return stream << static_cast<typename std::underlying_type<T>::type>(e);
}
```

# 不要在构造或析构期间调用虚函数

构造或析构函数中调用virtual函数不会呈现出多态。

- 基类的构造函数先于子类的构造函数。在基类构造函数期间，子类的对象还没有构建，如果子类的虚函数用到了 local 变量，这时如果真的调用了子类的虚函数，会使用为初始化的变量，会有不明确的行为。所以 C++ 不让你走这条路
- 在基类构造期间，对象类型是基类，不是子类。虚函数会被编译器解析到基类。如果使用了运行期类型信息（例如，dynamic_cast 和 typeid），编译器也会把它视为基类类型

```
//@ 基类
class Transaction {
public:
	Transaction();
	virtual void logTransaction() const { std::cout << "Transaction logTransaction" << std::endl; };
};

Transaction::Transaction()
{
	logTransaction(); //@ 构造函数中调用虚函数
}

//@ 买家子类 
class BuyTransaction : public Transaction {
public:
	virtual void logTransaction() const { std::cout << "BuyTransaction logTransaction" << std::endl; }
};

//@ 卖家子类 
class SellTransaction : public Transaction {
public:
	virtual void logTransaction() const { std::cout << "SellTransaction logTransaction" << std::endl; };
};

int main()
{
	BuyTransaction b;
	return 0;
}
```

相同的道理同样适用于析构函数。析构过程和构造过程相反。先析构派生类部分，再析构基类部分。析构到基类时，派生类中的变量就是未初始化的，对象类型是基类类型。

# 赋值运算符要返回自身的引用

赋值运算符需要支持连锁赋值，与其类似的 operator+=、operator-= 等改变左侧操作符的运算，都应该返回引用。这是一个协议，应该去遵守。

```
class Widget{
public:
	Widget()
	{
		std::cout << "Default Ctor" << std::endl;
	}

	Widget(const Widget& rhs)
	{
		std::cout << "Copy Ctor" << std::endl;
	}

	Widget& operator=(const Widget& rhs)
	{
		std::cout << "operator=" << std::endl;
		return *this;
	}
};
```

# 赋值运算符的自赋值问题

防止这个错误的传统方法是在 operator= 的开始处通过一致性检测来阻止自赋值：

```
Widget& Widget::operator=(const Widget& rhs)
{
	if (this == &rhs)  //@ 证同测试
		return *this;

	delete pb;
	pb = new Bitmap(*rhs.pb);

	return *this;
}
```

这个版本能够解决自赋值安全，但是不能解决异常安全，例如：如果 "new Bitmap" 表达式引发一个异常（可能因为供分配的内存不足或者因为 Bitmap 的拷贝构造函数抛出一个异常），Widget 将以持有一个指向被删除的 Bitmap 的指针而告终。这样的指针是你不能安全地删除它们，你甚至不能安全地读取它们。

下面方法可以实现异常安全：

```
Widget& Widget::operator=(const Widget& rhs)
{
  Bitmap *pOrig = pb;              
  pb = new Bitmap(*rhs.pb);        
  delete pOrig;                   

  return *this;
}
```

copy and swap 技术：

```
class Widget {
  ...
  void swap(Widget& rhs);      
  ...                         
};

Widget& Widget::operator=(const Widget& rhs)
{
  Widget temp(rhs);            
  swap(temp);                  
  return *this;
}
```

如果赋值操作符参数是值传递，那么就不需要新建临时变量，直接使用函数参数即可：

```
Widget& Widget::operator=(const Widget rhs)
{      
  swap(rhs);                  
  return *this;
}
```

