#  Lambda 表达式

Lambda 表达式的基本语法如下：

```
[捕获列表](参数列表) mutable(可选) 异常属性 -> 返回类型 {
	// 函数体
}
```

默认情况下，参数列表为空时，可以省略参数列表。

## 捕获列表

lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：

### 值捕获

与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 lambda 表达式被创建时拷贝，
而非调用时才拷贝：

```
void lambda_value_capture() {
	int value = 1;
	auto copy_value = [value]
	{
		return value;
	};

	value = 100;
	auto stored_value = copy_value();
	std::cout << "stored_value: " << stored_value << std::endl; //@ stored_value 是 1
}
```

### 引用捕获

与引用传参类似，引用捕获保存的是引用，值会发生变化。

```
void lambda_reference_capture() {
	int value = 1;
	auto copy_value = [&value] {
		return value;
	};

	value = 100;
	auto stored_value = copy_value();
	std::cout << "stored_value = " << stored_value << std::endl; //@ stored_value 是 100
}
```

### 隐式捕获

可以在捕获列表中写一个 & 或 = 向编译器声明采用引用捕获或者值捕获。捕获列表的最常用的四种形式可以是：

- \[\] 空捕获列表
- \[name1, name2, ...\] 捕获一系列变量
- \[&\] 引用捕获, 让编译器自行推导捕获列表，修改变量后外部变量同步修改
- \[=\] 值捕获, 让编译器执行推导捕获列表，按值捕获时，默认情况下 lambda 体中不允许修改变量的值

使用 mutable 修饰，修改变量后外部变量不会同步修改。如果使用 mutable 修饰，即使没有参数，也需要写明参数列表：

```
int a = 1;
auto f = [=]() {return ++a; };  //@ 错误，不允许修改
auto f = [=]() mutable {return ++a; };  //@ 可以修改 a，但是 lambda 表达式外部的 a 的值不变
auto f = [&]() mutable {return ++a; };  //@ 可以修改 a，但是 lambda 表达式外部的 a 的值同步改变
```

### 表达式捕获

C++14 允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 `auto` 本质上是相同的：

```
int main() {
	auto important = std::make_unique<int>(1);
	auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -> int {
		return x + y + v1 + (*v2);
	};
	std::cout << add(3, 4) << std::endl;
	return 0;
}
```

## 返回值

返回值采用后置的语法实现。

允许省略返回值类型定义，编译器会根据语句自动推导：

- 采用自动推导时，如果有多处返回，类型需要保持一致
- 不能推导初始化列表

```
//@ 错误，lambda 无法推导返回类型
auto f = [](int x) 
{
    if (x & x)
   	 	return 0.0;
    else
    	return 1;
};

//@ 错误，无法根据初始化列表自动推导
auto f = []()
{
	return { 1,2 };
};
```

## 泛型 lambda 

从 C++14 开始，lambda  函数的形式参数可以使用 auto 关键字来产生意义上的泛型：

```
auto add = [](auto x, auto y) {
    return x+y;
};

add(1, 2);
add(1.1, 2.2);
```

## lambda 表达式的类型

lambda 表达式在 C++ 11 中称为闭包类型，可以将其理解为一个带 operator() 的类，即仿函数。因而可以使用 std::function 来存储 lambda 表达式，也可以使用 std::bind  来操作 lambda 表达式。

lambda  表达式的 operator() 是 const 的，这也是为什么按值捕获无法修改变量的本质原因，使用 mutable 则取消了 operator() 的 const ，因而可以修改变量。

```
std::function<int(int)> f1 = [](int a) {return a; };
std::function<int(void)> f2 = std::bind([](int a) { return a; },123);
```

没有捕获任何变量的 lambda 表达式，可以转换成一个普通的函数指针：

```
using func_t = int(*)(int);
func_t f = [](int a) { return a; };
f(12);
```

## lambda 表达式的优点

lambda 表达式来源于函数式编程的概念，其具有以下优点：

- 声明式编程风格：就地匿名定义目标函数或者函数对象，不需要额外写一个命名函数或者函数对象，不需要额外写函数或者函数对象，避免了代码膨胀和功能分散
- 更灵活：在需要的时间地点实现函数闭包

声明式编程：

```
std::vector<int> vec{1,2,3,4,5,6,7,8,9};
int even_count{ 0 };
std::for_each(vec.begin(), vec.end(), [&even_count](int x) {if (!(x & 1)) ++even_count; }); //@ 不需要提前定义仿函数
```

在需要的时间地点实现函数闭包：

```
std::vector<int> vec{1,2,3,4,5,6,7,8,9};
std::count_if(vec.begin(), vec.end(), [](int val) {return val > 5 && val <= 10; });  //@ 大于 5 小于等于10
```

# 函数对象包装器

## 可调用对象

- 函数指针
- 具有 `operator()` 成员函数的类对象(仿函数)
- 可以转换成函数指针的类对象
- 类的成员(函数)指针

```
void func(void)
{
	std::cout << "func" << std::endl;
}

struct Foo
{
	void operator()(void)
	{
		std::cout << "functor" << std::endl;
	}
};

struct Bar
{
	using fr_t = void(*)(void);

	static void func(void)  //@ 必须是静态函数，没有隐式的 this 参数
	{
		std::cout << "Bar::func" << std::endl;
	}

	operator fr_t(void)
	{
		return func;
	}
};

struct A
{
	int i_;
	void mem_func(void)
	{
		std::cout << "mem_func" << std::endl;
	}
};

int main()
{
	//@ 函数指针,也可以直接写成 void(*func_ptr)(void) = func;
	void(*func_ptr)(void) = &func; 
	func_ptr();

	//@ 仿函数
	Foo foo;
	foo(); 

	//@ 可转换为函数指针的类对象
	Bar bar;
	bar();  

	void (A::*mem_func_ptr)(void) = &A::mem_func;  //@ 类成员函数指针，这里必须使用 & 
	int A::*mem_obj_ptr = &A::i_;	 //@ 类成员指针
	A a;
	(a.*mem_func_ptr)();
	a.*mem_obj_ptr = 123;

	return 0;
}
```

## std::function

std::function 是可调用对象的包装器，是一个类模板，可以容纳除了类成员(函数)指针以外所有的可调用对象。

std::function 是一种通用、多态的函数封装，它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，它也是对 C++ 中现有的可调用实体的一种类型安全的包裹，换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。

```
void func(void)
{
	std::cout << __FUNCTION__ << std::endl;
}

class Foo
{
public:
	static int foo_func(int a)
	{
		std::cout << __FUNCTION__ << "("<<a<<")"<<std::endl;
		return a;
	}
};

class Bar
{
public:
	int operator()(int a)
	{
		std::cout << __FUNCTION__ << "(" << a << ")" << std::endl;
		return a;
	}
};

int main()
{
	std::function<void(void)> fr1 = func;  //@ 绑定一个普通函数
	fr1();
	
	std::function<int(int)> fr2 = Foo::foo_func; //@ 绑定类的静态成员函数
	fr2(2);

	Bar bar;
	std::function<int(int)> fr3 = bar; //@ 绑定一个仿函数
	fr3(1);

	return 0;
}
```

## std::bind 和 std::placeholder

不论是普通函数、函数对象、还是成员函数，成员变量都可以绑定。

std::bind 作用：

- 将可调用对象与其参数绑定成一个仿函数
- 改变函数调用时需要传参的个数和顺序
- 先将可调用的对象保存起来，在需要的时候再调用，是一种延迟计算的思想

改变参数的个数和调用顺序：

```
void func(int a, char c, float f)
{
	std::cout << a << " " << c << " " << f << std::endl;
}

int main()
{
	//@ 使用占位符
	auto f1 = std::bind(func, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);
	f1(1, 'c', 3.14);

	//@ 改变传参顺序
	auto f2 = std::bind(func, std::placeholders::_2, std::placeholders::_3, std::placeholders::_1);
	f2(3.14,1,'c');

	//@ 使用固定参数改变参数个数
	auto f3 = std::bind(func, std::placeholders::_1, std::placeholders::_2, 3.14);
	f3(1,'c');
	f3(1, 'c', 9.999); //@ 第三个参数将会被忽略掉

	return 0;
}
```

绑定类的成员(函数)：

```
class Test
{
public:
	int mem_func(int a) 
	{
		std::cout << a << std::endl;
		return a + 1;
	}

	void mem_func2(int a, char c, float f)
	{
		std::cout << a << " " << c << " " << f << std::endl;
	}

	static int static_mem_func(int a)
	{
		std::cout << a << std::endl;
		return a + 100;
	}

public:
	int mem_variable = 1024;
};


int main()
{
	Test t;
	
	//@ 绑定成员函数
	auto f1 = std::bind(&Test::mem_func,t,std::placeholders::_1);
	f1(2);

	//@ 绑定多参数成员函数，改变传参顺序
	auto f2 = std::bind(&Test::mem_func2, t, std::placeholders::_3, std::placeholders::_2, std::placeholders::_1);
	f2(2.13, 'a',100);

	//@ 绑定静态成员函数
	auto f3 = std::bind(&Test::static_mem_func,std::placeholders::_1);
	f3(100);

	//@ 绑定成员变量
	auto f4 = std::bind(&Test::mem_variable,std::placeholders::_1);
	int var = f4(t);
	std::cout << var << std::endl;

	return 0;
}
```

绑定仿函数：

```
struct Test
{
	void operator()(int n)
	{
		std::cout << n << std::endl;
	}
};

int main()
{
	auto f1 = std::bind(Test(),std::placeholders::_1);
	f1(1000);

	Test t;
	auto f2 = std::bind(t, 10);
	f2();

	return 0;
}
```

std::function 不能容纳类的成员(函数)但是 std::bind 可以绑定类的成员(函数)，std::bind 之后的对象可以使用 std::function 表示，从而实现可调用对象的统一表示方法。std::bind1st 和 std::bind2nd 是旧标准库中用于将二元算子转换成一元算子的方法：

```
	std::vector<int> vec{ 1,2,3,4,5,6,7,8,9,10 };

	//@ 旧标准
	int count1 = std::count_if(vec.begin(), vec.end(), std::bind1st(std::less<int>(), 5)); //@ 第一个参数固定为5，查找大于 5 的元素个数
	int count2 = std::count_if(vec.begin(), vec.end(), std::bind2nd(std::less<int>(), 5)); //@ 第二个参数固定为5，查找小于 5 的元素个数

	//@ 新标准
	int count3 = std::count_if(vec.begin(), vec.end(), std::bind(std::less<int>(), 5, std::placeholders::_1)); 
	int count4 = std::count_if(vec.begin(), vec.end(), std::bind(std::less<int>(), std::placeholders::_1, 5)); 
```

复合多个函数(闭包)：

```
std::vector<int> vec{ 1,2,3,4,5,6,7,8,9,10 };

using std::placeholders::_1;

auto f = std::bind(std::logical_and<bool>(),
    std::bind(std::greater<int>(),_1,5),
    std::bind(std::less_equal<int>(), _1, 10)
    );

int count = std::count_if(vec.begin(),vec.end(),f);
```

# 右值引用

## 左值、右值的纯右值、将亡值、右值

- 左值是表达式结束后依然存在的持久对象，右值是表达式结束就不会继续存在的临时对象
- 如果能对表达式取地址就是左值，否则就是右值
- 具名变量或对象都是左值，而右值是不具名的

C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。C++ 11 中所有的值必属于：左值，将亡值，纯右值 三者之一，将亡值和纯右值都属于右值。

C++ 11 中右值由两个概念构成：

- 一个是将亡值
  - 将要被移动的对象
  - T&& 类型函数返回值
  - std::move 返回值
  - 转换为 T&& 的类型的转换函数的返回值

- 一个是纯右值

  - 非引用返回的临时变量
  - 运算表达式产生的临时变量
  - 原始字面量
  - lambda 表达式

## 右值引用和左值引用

右值引用是对一个右值进行引用的类型，因为右值不具名，只能通过引用的方式找到它。

需要注意：

- 无论左值引用还是右值引用都必须立即进行初始化
- 常量左值引用是一个 "万能" 引用，可以接受左值，右值，常量左值，常量右值。普通的左值引用不能接受右值

```
void f1(std::string& str)
{}

void f2(const std::string& str)
{}

f1("hello,world");  //@ 错误，普通左值引用不能绑定右值
f2("hello,world");  //@ 正确，const 左值引用是万能引用类型

std::string lv1 = "string,"; //@ lv1 是一个左值
std::string&& r1 = lv1; //@ 非法, 右值引用不能引用左值
```

## 移动语义

传统的 C++ 没有区分移动和拷贝的概念，造成了大量的数据拷贝，浪费时间和空间。右值引用的出现解决了这两个概念的混淆问题。

```
int main() {

	std::string str = "Hello world.";
	std::vector<std::string> v;

	//@ 将使用 push_back(const T&), 即产生拷贝行为
	v.push_back(str);

	//@ 将使用 push_back(const T&&), 不会出现拷贝行为
	//@ 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销
	//@ 这步操作后, str 中的值会变为空
	v.push_back(std::move(str));

	return 0;
}
```

C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象。

std::move 只是转移了资源的控制权，本质上是将左值强制转换为右值，以使用移动语义，避免含有资源的对象发生了无谓的拷贝。

- move 对于拥有内存，文件句柄等资源对象的成员有效
- 如果是一些基本类型，比如 int 和 char[10] 数组等，如果使用 move 还是会发生拷贝，因为它们没有对应的移动构造函数

## 完美转发

引用折叠：

![](./img/reference.png)

无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型。

完美转发实现了参数在传递过程中保持其值属性的功能，即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。

完美转发利用 std::forward 实现：

- std::forward 不仅可以保持左值或者右值不变，同时还可以保持 CV 和引用等属性不变
- std::forward 只有在它的参数绑定到一个右值上的时候，它才转换参数到右值

```
template <typename T>
void printT(T& t)
{
	std::cout << "lvalue" << std::endl;
}

template <typename T>
void printT(T&& t)
{
	std::cout << "rvalue" << std::endl;
}

template<typename T>
void test_forward(T&& t)
{
	printT(std::forward<T>(t));
}

int main()
{
	int x = 1;

	test_forward(1); //@ rvalue
	test_forward(x); //@ lvalue
	test_forward(std::forward<int>(x)); //@ rvalue
	test_forward(std::forward<int&>(x)); //@ lvalue
	test_forward(std::forward<int&&>(x)); //@ rvalue
	test_forward(std::move(x)); //@ rvalue

	return 0;
}
```

右值引用、完美转发再结合可变模板参数可以写一个万能的函数包装器：

```
template<class Function, class...Args>
inline auto function_wrapper(Function&& func, Args&&...args)->decltype(func(std::forward<Args>(args)...))
{
	return func(std::forward<Args>(args)...);
}
```

引用：

```
template<class Function, class...Args>
inline auto function_wrapper(Function&& func, Args&&...args)->decltype(func(std::forward<Args>(args)...))
{
	return func(std::forward<Args>(args)...);
}

void test0()
{
	std::cout << "void" << std::endl;
}

int test1()
{
	return 1;
}

int test2(int x)
{
	return x;
}

std::string test3(const std::string s1, const std::string s2)
{
	return s1 + s2;
}


int main()
{
	function_wrapper(test0);  //@ 没有返回值
	auto res1 = function_wrapper(test1);  //@ 返回1
	auto res2 = function_wrapper(test2, 2);		//@ 返回2
	auto res3 = function_wrapper(test3, "aa", "bb");   //@ 返回aabb


	return 0;
}
```

std::forward 和 std::move 一样，没有做任何事情，std::move 单纯的将左值转化为右值，std::forward 也只是单纯的将参数做了一个类型的转换，从现象上来看，std::forward<T>(v) 和 static_cast<T&&>(v) 是完全一样的。

```
template<typename _Tp>
constexpr _Tp&& forward(typename std::remove_reference<_Tp>::type& __t) noexcept
{ return static_cast<_Tp&&>(__t); }

template<typename _Tp>
constexpr _Tp&& forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
{
    static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
        " substituting _Tp is an lvalue reference type");
    return static_cast<_Tp&&>(__t);
}
```

# emplace_back 

emplace_back 能就地通过函数构造对象，不需要拷贝或者移动内存，相比于 push_back  能更好地避免内存的拷贝与移动，使容器插入元素的性能得到进一步提升。在大多数情况下应该优先使用 emplace_back 来代替 push_back。标准库中类似的方法有：emplace，emplace_hint，emplace_front，emplace_after，emplace_back。

emplace_back  通过构造函数的参数就可以构造对象，因此，要求对象有相应的构造函数，如果没有会编译报错。

```
struct Complicated
{
	int year_;
	double country_;
	std::string name_;

	Complicated(int a, double b, std::string s) : year_(a), country_(b), name_(s)
	{
		std::cout << "is constructed" << std::endl;
	}

	Complicated(const Complicated& other) : year_(other.year_), country_(other.country_), name_(other.name_)
	{
		std::cout << "is copied" << std::endl;
	}

	Complicated(Complicated&& other) : year_(other.year_), country_(other.country_), name_(other.name_)
	{
		std::cout << "is moved" << std::endl;
	}
};

int main()
{
	std::map<int, Complicated> m;
	int i = 4;
	double d = 5.0;
	std::string s = "C++";

	std::cout << "---insert---" << std::endl;
	m.insert(std::make_pair(1, Complicated(i, d, s)));

	std::cout << "---emplace---" << std::endl;
	m.emplace(2, Complicated(i, d, s));

	std::vector<Complicated> v;
	std::cout << "---emplace_back---" << std::endl;
	v.emplace_back(i, d, s);

	std::cout << "---push_back---" << std::endl;
	v.push_back(Complicated(i, d, s));

	return 0;
}
```





























