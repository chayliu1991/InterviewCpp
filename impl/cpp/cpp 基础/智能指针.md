# RAII 与引用计数

对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次，每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。



# std::shared_ptr

std::shared_ptr 能够记录多少个 shared_ptr 共同指向一个对象，从而消除显示的调用 delete，当引用计数变为零的时候就会将对象自动删除。

std::make_shared  能够用来消除显式的使用 new，所以 std::make_shared  会分配创建传入参数中的对象，并返回这个对象类型的 std::shared_ptr 指针。

std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数，并通过 use_count() 来查看一个对象的引用计数。

# std::unique_ptr

std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全。

```
std::unique_ptr<int> pointer = std::make_unique<int>(10); //@ make_unique 从 C++14 引入
std::unique_ptr<int> pointer2 = pointer; //@ 非法
```

make_unique 并不复杂，C++11 没有提供 std::make_unique，可以自行实现：

```
template <typename T,typename ... Args>
std::unique_ptr<T> make_unique(Args&& ... args)
{
	return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}
```

既然是独占，换句话说就是不可复制。但是，可以利用 std::move  将其转移给其他的 unique_ptr。

# std::weak_ptr

```
struct A;
struct B;

struct A {
	std::shared_ptr<B> pointer;
	~A() {
		std::cout << "A destroy" << std::endl;
	}
};

struct B {
	std::shared_ptr<A> pointer;
	~B() {
		std::cout << "B destroy" << std::endl;
	}
};

int main() {
	auto a = std::make_shared<A>();
	auto b = std::make_shared<B>();
	a->pointer = b;
	b->pointer = a;
}
```

运行结果是 A, B 都不会被销毁，也就造成了内存泄露：

![](./img/sp_sp.png)

解决这个问题的办法就是使用弱引用指针 std::weak_ptr，std::weak_ptr 是一种弱引用（相比较而言 std::shared_ptr 就是一种强引用）。弱引用不会引起引用计数增加。

![](./img/sp_wp.png)

std::weak_ptr  没有 * 运算符和 -> 运算符，所以不能够对资源进行操作，它的唯一作用就是用于检查 std::shared_ptr 是否存在，其 expired() 方法能在资源未被释放时，会返回 true，否则返回 false。







