# 编译阶段编程

```
template <int N>
struct Fib
{
	static_assert(N >= 0,"N >= 0");
	static const int value = Fib<N - 1>::value + Fib<N - 2>::value;
};

template <>
struct Fib<1>
{
	static const int value = 1;
};

template <>
struct Fib<0>
{
	static const int value = 1;
};


int main()
{
	std::cout << Fib<2>::value << std::endl; 
	std::cout << Fib<40>::value << std::endl;
	return 0;
}
```

# 编译期类型推导  

C++ 标准库在 `<type_traits>` 头文件里定义了很多工具类模板，用来提取某个类型在某方面的特点。这些特点既是类型，又是常值。 为了方便地在值和类型之间转换，标准库定义了一些经常需要用到的工具类。为了方便使用，针对布尔值有两个额外的类型定义：    

```
typedef std::integral_constant<bool, true> true_type;
typedef std::integral_constant<bool, false> false_type;
```

这两个标准类型 true_type 和 false_type 经常可以在函数重载中见到：

```
template <typename T>
class SomeContainer
{
public:
	static void destroy(T *ptr)
	{
		_destroy(ptr, std::is_trivially_destructible<T>());
	}

private:
	static void _destroy(T* ptr,std::true_type)
	{}

	static void _destroy(T* ptr, std::false_type)
	{
		ptr->~T();
	}
};
```

除了得到布尔值和相对应的类型的 trait 模板，我们还有另外一些模板，可以用来做一些类型的转换。以一个常见的模板 remove_const 为例：

```
template <typename T>
struct remove_const {
	typedef T type;
};

template <typename T>
struct remove_const <const T>{
	typedef T type;
};
```

如果我们对 const string& 应用 remove_const，就会得到 string&，即，remove_const<const string&>::type 等价于 string&。  

如果对 const char* 应用 remove_const 的话，结果还是 const char*。原因是，const char* 是指向 const char 的指针，而不是指向char 的 const 指针。如果我们对 char * const 应用 remove_const 的话，还是可以得到 char* 的。  

如果你觉得写 is_trivially_destructible<T>::value 和 remove_const<T>::type 非常啰嗦的话，在当前的 C++ 标准里，前者有增加 _v 的编译时常量，后者有增加 _t 的类型别名：    

```
template <class T>
inline constexpr bool is_trivially_destructible_v = std::is_trivially_destructible<T>::value;

template <class T>
using remove_const_t = typename remove_const<T>::type;
```

# 外部模板

模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板的实例化。

为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化：

```
template class std::vector<bool>;          //@ 强行实例化

extern template class std::vector<double>; //@ 不在该当前编译文件中实例化模板
```

# 类型别名模板

模板是用来产生类型的。在传统 C++ 中，typedef  可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：

```
template <typename T>
typedef std::map<std::string, T> map_t;  //@ 错误
```

但是 C++ 11 中，使用 using 声明可以实现这个目的：

```
template <typename T>
using map_t = std::map<std::string, T> ;
```

typedef 对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。使用 using 声明的形式则容易理解：

```
typedef int (*process)(void *);

using NewProcess = int(*)(void *);
```

# 默认模板参数

在 C++11 中提供了一种便利，可以指定模板的默认参数：

```
template<typename T = int, typename U = int>
auto add(T x, U y) -> decltype(x+y) {
    return x+y;
}
```

# 函数模板的默认参数

C++ 11 之前允许类模板有默认参数，但是不允许函数模板有默认参数：

```
template <typename T,typename U = int,U N = 0>
struct Foo {};


template <typename T = int>  //@ C++ 11 之前不允许
void func()
{}
```

但是 C++ 11 中解除了上述对于函数模板默认参数的限制，在 C++ 11 中可以直接调用：

```
func();   //@ 如同一个普通函数
```

函数模板的默认参数不需要在数列表中从右向左书写，而是可以出现在任意位置：

```
template <typename X,typename T = int, typename U>
T func(X val1,U val2)
{
	return static_cast<int>(val1 + val2);
}
```

# 变长参数模板

声明可变参数模板时需要在 class 或 typename 关键字前面加上 ...：

- 声明一个参数包，这个参数包中可以包含 0 个到任意个模板参数
- 在模板定义的右边，可以将参数包展开成一个一个独立的参数

```
template<typename... Ts> 
class Magic;
```

模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如：

```
class Magic<int, std::vector<int>, std::map<std::string, std::vector<int>>> darkMagic;

class Magic<> nothing;
```

如果不希望产生的模板参数个数为0，可以手动的定义至少一个模板参数：

```
template<typename Require, typename... Args> 
class Magic;
```

可以使用 `sizeof...` 来计算参数的个数：

```
template<typename... Ts>
void magic(Ts... args) {
    std::cout << sizeof...(args) << std::endl;
}
```

对参数进行解包的方法：

递归模板函数：递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的。

```
template<typename T>
void print(T value) 
{
	std::cout << value << std::endl;
}

template<typename T, typename... Args>
void print(T value, Args... args)
{
	std::cout << value << std::endl;
	print(args...);
}

int main() 
{
	print(1, 2, "123", 1.1);
	return 0;
}
```

递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。

初始化列表展开：

```
template<typename T, typename... Args>
auto print(T value, Args... args)
{
	std::cout << value << std::endl;
	std::initializer_list<T>{([&args] 
	{
		std::cout << args << std::endl;
	}(), value)...};
}
```

变参模板展开：C++17 中增加了变参模板展开的支持。

```
template<typename T, typename... Args>
void print(T t, Args... args) 
{
	std::cout << t << std::endl;
	if constexpr (sizeof...(args) > 0) 
		print(t...);
}
```

# 非类型模板参数推导

还有一种常见模板参数形式可以让不同字面量成为模板参数，即非类型模板参数：

```
template <typename T, int BufSize>
class buffer_t {
public:
    T& alloc();
    void free(T& item);
private:
    T data[BufSize];
}

buffer_t<int, 100> buf; // 100 作为模板参数
```

# 模板编程

## SFINAE  

SFINAE  即替换失败非错（substituion failure is not an error）。

### 函数模板的重载决议  

当一个函数名称和某个函数模板名称匹配时，重载决议过程大致如下：    

- 根据名称找出所有适用的函数和函数模板
- 对于适用的函数模板，要根据实际情况对模板形参进行替换；替换过程中如果发生错误，这个模板会被丢弃
- 在上面两步生成的可行函数集合中，编译器会寻找一个最佳匹配，产生对该函数的调用
- 如果没有找到最佳匹配，或者找到多个匹配程度相当的函数，则编译器需要报错  

```
struct Test final
{
	typedef int foo;
};

template <typename T>
void f(typename  T::foo)
{
	std::cout << "f(typename  T::foo)" << std::endl;
}


template <typename T>
void f(T)
{
	std::cout << "f(T)" << std::endl;
}

int main()
{
	f<Test>(10); //@ f(Test::foo)
	f<int>(10); //@ f(10),f(int::foo) 不合法
	return 0;
}
```

在这儿，体现的是 SFINAE 设计的最初用法：如果模板实例化中发生了失败，没有理由编译就此出错终止，因为还是可能有其他可用的函数重载的。  

SFINAE 可以用于其他用途。比如，根据某个实例化的成功或失败来在编译期检测类的特性。  

```
template <typename T>
struct HasReserve
{
	//@ 定义 good，bad类，只需要关注它们大小不一样
	struct good { char dummy; };
	struct bad { char dummy[2]; };

	//@ 定义 SFINAE 模板，但是模板的第二个参数是第一个参数的成员函数指针，输入参数 size_t,返回 void
	template <class U,void (U::*)(size_t)>
	struct SFINAE {};

	template <class U>
	static good	reserve(SFINAE<U, &U::reserve>*);

	template<class U>
	static bad reserve(...);

	//@ 定义常整型布尔值 value，结果是 true 还是 false，取决于 nullptr 能
	//@不能和 SFINAE* 匹配成功，而这又取决于模板参数 T 有没有返回类型是 void、接受一
	//@ 个参数并且类型为 size_t 的成员函数 reserve
	static const bool value = sizeof(reserve<T>(nullptr)) == sizeof(good);
};
```

### SFINAE 模板技巧  

C++11 开始，标准库里有了一个叫 enable_if 的模板，可以用它来选择性地启用某个函数的重载。 例如：

```
template <typename C, typename T>
enable_if_t<HasReserve<C>::value, void>	append(C& container, T* ptr, size_t size)
{
	container.reserve(
		container.size() + size);
	for (size_t i = 0; i < size;
		++i) {
		container.push_back(ptr[i]);
	}
}

template <typename C, typename T>
enable_if_t<!HasReserve<C>::value, void> append(C& container, T* ptr, size_t size)
{
	for (size_t i = 0; i < size;
		++i) {
		container.push_back(ptr[i]);
	}
}
```

对于某个 type trait，添加 _t 的后缀等价于其 type 成员类型。因而，我们可以用 enable_if_t 来取到结果的类型。  

enable_if_t<HasReserve<C>::value, void> 的意思可以理解成：如果类型 C 有reserve 成员的话，那我们启用下面的成员函数，它的返回类型为 void。

decltype 返回值：

如果只需要在某个操作有效的情况下启用某个函数，而不需要考虑相反的情况的话，有另外一个技巧可以用。对于上面的 append 的情况，如果我们想限制只有具有 reserve 成员函数的类可以使用这个重载  

```
template <typename C, typename T>
auto append(C& container, T* ptr,size_t size)-> decltype(declval<C&>().reserve(1U),void())
{
	container.reserve(
		container.size() + size);
	for (size_t i = 0; i < size;
		++i) {
		container.push_back(ptr[i]);
	}
}
```

declval  模板用来声明一个某个类型的参数，但这个参数只是用来参加模板的匹配，不允许实际使用。使用这个模板，我们可以在某类型没有默认构造函数的情况下，假想出一个该类的对象来进行类型推导。declval<C&>().reserve(1U) 用来测试 C& 类型的对象是不是可以拿 1U 作为参数来调用 reserve 成员函数。此外，我们需要记得，C++ 里的逗号表达式的意思是按顺序逐个估值，并返回最后一项。所以，上面这个函数的返回值类型是 void。  

标签分发：

```
template <typename C, typename T>
void _append(C& container, T* ptr, size_t size, true_type)
{
	container.reserve(container.size() + size);
	for (size_t i = 0; i < size; ++i)
	{
		container.push_back(ptr[i]);
	}
}

template <typename C, typename T>
void _append(C& container, T* ptr, size_t size, false_type)
{
	for (size_t i = 0; i < size;
		++i) {
		container.push_back(ptr[i]);
	}
}

template <typename C, typename T>
void append(C& container, T* ptr, size_t size)
{
	_append(container, ptr, size, integral_constant<bool, has_reserve<C>::value>{});
}
```

这个代码跟使用 enable_if 是等价的。当然，在这个例子，标签分发并没有使用 enable_if 显得方便。 

















