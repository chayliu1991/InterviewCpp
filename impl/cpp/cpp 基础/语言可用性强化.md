# 常量

## nullptr

传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 `((void*)0)`，有些则会直接将其定义为 0。

C++ 不允许直接将 `void *` 隐式转换到其他类型。但如果编译器尝试把 NULL 定义为 `((void*)0)`，那么在下面这句代码中：

```
char *ch = NULL; //@ 不合法
```

而将 NULL 定义成 0 将导致 C++ 中重载特性发生混乱：

```
void foo(char*);
void foo(int);

//@ 实际调用 foo 函数
foo(NULL); //@ 将调用 foo(int)
```

为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。

```
if (std::is_same<decltype(NULL), decltype(0)>::value)
	std::cout << "NULL == 0" << std::endl;
if (std::is_same<decltype(NULL), decltype((void*)0)>::value)
	std::cout << "NULL == (void*)0" << std::endl;
if (std::is_same<decltype(NULL), std::nullptr_t>::value)
	std::cout << "NULL == nullptr" << std::endl;
```

## constexpr

### constexpr 变量  

常量表达式指值不会改变并且在编译过程就能得到计算结果的表达式，一个对象是否为常量表达式由它的数据类型和初始值共同决定：

字面值是常量表达式，由常量表达式初始化的 const 对象也是常量表达式：

```
const int max_files = 20;           //@ max_files 是常量表达式
const int limit = max_files + 1;    //@ limit 是常量表达式
int staff_size = 27;        //@ staff_size 不是常量表达式
const int sz = get_size();  //@ sz 不是常量表达式
```

C++11 允许将变量声明为 constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式。

声明为 constexpr 的变量一定是一个常量：

- constexpr 变量必须立即初始化  
- 初始化只能使用字面量或常量表达式，后者不允许调用任何非 constexpr 函数  

```
constexpr int mf = 20;          //@ 20 是常量表达式
constexpr int limit = mf + 1;   //@ mf + 1 是常量表达式
constexpr int sz = size();      //@ 仅当 size 函数是常量函数时才合法
```

一般来说，如果你认定变量是一个常量表达式，那就把它声明成 constexpr 类型。

const 和 constexpr 限定的值都是常量。但 constexpr 对象的值必须在编译期间确定，而 const 对象的值可以延迟到运行期间确定。

与 const 不同，在 constexpr  声明中如果定义了一个指针，限定符 constexpr 仅对指针本身有效，与指针所指的对象无关：

```
constexpr int *p1 = nullptr;	//@ p1 是指向 int 的 const 指针
const int * p2 = nullptr;		//@ p2 是指向 const int 的普通指针	
constexpr const int * p3 = nullptr;   //@ p3 是指向 const int 的 const 指针	
```

### constexpr 函数

constexpr 函数是指能用于常量表达式的函数，要检验一个 constexpr 函数能不能产生一个真正的编译期常量，可以把结果赋给一个constexpr 变量。成功的话，我们就确认了。

C++ 11 中对 constexpr 函数的约定：

- 函数体中必须有且只有一条 return 语句，并且函数必须有返回值
- 在使用前必须已经定义
- 体内可以包含其它语句，但是这些语句在运行时不执行任何操作就行。例如，可以有空语句、类型别名以及 using 声明

```
constexpr int new_sz() { return 42; }
constexpr int foo = new_sz();
```

从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句：

```
constexpr int fibonacci(const int n) {
    if(n == 1) return 1;
    if(n == 2) return 1;
    return fibonacci(n-1) + fibonacci(n-2);
}

//@ C++ 11 中只能写作：
constexpr int fibonacci(const int n) {
    return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2);
}
```

### 字面值常量类

constexpr函数的参数和返回值必须是字面值类型，除了算术类型、引用和指针外，某些类也是字面值类型：

- 数据成员都是字面值类型的聚合类是字面值常量类
- 如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：
  - 数据成员都必须是字面值类型
  - 类必须至少含有一个 constexpr 构造函数
  - 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr 构造函数
  - 类必须使用析构函数的默认定义，该成员负责销毁类的对象

```
struct Date final
{
	constexpr Date(int y, int m, int d) noexcept : year_(y), month_(m), day_(d) {}

	constexpr int get_year() const noexcept { return year_; }
	constexpr int get_month() const noexcept { return month_; }
	constexpr int get_day() const noexcept { return day_; }

private:
	int year_;
	int month_;
	int day_;
};

//@ 应用
Date PRCFound = { 1949,10,1 };
```

# 变量及其初始化

## 初始化列表

### 统一初始化方法

列表初始化统一了初始化方法，它可以用于任何类型对象的初始化：

```
int arr[]{ 1,2,3 };  //@ 初始化数组

//@ 初始化 STL
std::map<std::string, int> mm = { {"1",1},{ "2",2} ,{ "3",3 } ,{ "4",4 } };
std::set<int> ss{1,2,3,4,5,6};
std::vector<int> vec{1,2,3,4,5};

struct A
{
    int x;
    struct B
    {
        int y;
        int z;
    }b;
};
A a{ 1,{ 2,3 } }; //@ 初始化 POD 类型

int* array = new int[3]{ 1,2,3 }; //@ 初始化动态分配的内存

class Foo
{
public:
	Foo(int,double) {}
};

Foo func()
{
	return{ 1,12.34 }; //@ 初始化返回类型
}
```

### 初始化列表的赋值方式

- 对于聚合类型的初始化将以拷贝的形式，用初始化列表中的值来初始化
- 对于其它类型，需要使用构造函数来初始化

聚合类型：

- 普通数组， int[10]，char[6]
- 类型是一个类(struct，class，union)并且：
  - 所有成员都是 public 的
  - 没有定义任何构造函数
  - 没有类内初始化
  - 无虚函数
  - 无基类

```
struct ST
{
	int x;
	double y;
protected:
	int z;
};
ST s{ 1,2.012,3 }; //@ 错误，类中有受保护的(私有的)非静态数据成员

struct ST
{
	int x;
	double y;
private:
	static int z;
};
ST s1{ 1,2.012}; //@ 正确
ST s2{ 1,2.012，3}; //@ 错误，静态成员不能通过初始化列表初始化，需要遵守静态成员的初始化方式

struct ST
{
	int x;
	double y;	
	virtual void func() {};
};
ST s{ 1,2.012}; //@ 错误，类中含有虚函数


struct Base {};
struct Derived : public Base
{
	int x;
	double y;	
};
Derived d{ 1,2.012}; //@ 错误，类有基类


struct ST
{
	int x;
	double y{ 0.0 }; //@ C++ 11 非静态数据成员允许声明时初始化，可以使用 {} 或者 =
};
ST s{1,2.3}; //@ 错误，类中包含了直接初始化的非静态数据成员
```

对于上述非聚合类型的类，要想使用初始化列表的唯一方法就是定义一个构造函数：

```
struct Base { virtual void func() {}; };
struct Derived : public Base
{
	Derived(int xx, double yy, int zz) : x(xx), y(yy), z(zz) {}
	int x;
	double y;

	virtual void func() {};

private:
	int z;
};
Derived d{ 1,2.012,3 };  //@ 正确
```

### 防止类型收窄

类型收窄是导致数据内容发生变化或者精度丢失的转换，初始化列表不支持这种转换：

- 浮点数转换成一个整型数，int i{2.1};
- 高精度浮点数转换成低精度浮点数，如从 long double 转换成 double 或者 float
- 整型数转换成浮点数，并且超过了浮点数的表示范围：float  x { (unsigned long long) -1};
- 整型数转换成长度较短的整型数，并且超过了较短整型数的表示范围，char x {65535}；

## 结构化绑定

C++17 给出的结构化绑定，可以让我们写出这样的代码：

```
std::tuple<int, double, std::string> f() {
    return std::make_tuple(1, 2.3, "456");
}

int main() {
    auto [x, y, z] = f();
    std::cout << x << ", " << y << ", " << z << std::endl;
    return 0;
}
```

# 类型推导

## auto

auto 声明的变量必须马上初始化，以让编译器推断出它的实际类型，并在编译时将 auto 占位符替换为真正的类型。

auto 使用注意事项：

- auto 总是推导出“值类型”，绝不会是“引用”
- 不显示指定为指针或者引用类型时，推导结果将丢弃 CV 属性
- auto 可以附加上 const、volatile、*、& 这样的类型修饰符，得到新的类型  

auto 的“自动推导”能力只能用在“初始化”的场合：

```
//@ 推导只能用在初始化形式中
auto x = 0UL; //@ x -> unsigned long
auto y = &x;  //@ y -> unsigned long
auto z{ &x }; //@ z -> unsigned long*
auto err; //@ 错误，没有用于推导的表达式

//@ 不显示指定，将丢弃引用
int a = 6;
int& r = a;
auto a1 = r;  //@ a1 -> int
auto& a2 = r; //@ a2 -> int&

//@ 不指定引用或者指针类型，将丢弃 cv 属性
const int i = 5;
const int& r = i;
auto a1 = r;  	//@ a1 -> int
auto& a2 = r;	//@ a2 -> const int&
auto b1 = &i; 	//@ b1 -> int* 
auto* b2 = &i;	//@ b2 -> const int*
```

auto 使用限制：

- 不能用于推导函数参数
- 不能用于推导类的非静态成员变量
- 不能用于推导数组
- 不能用于模板参数推导

```
void func(auto a = 1)  {} //@ 错误，auto 不能用于函数参数

class AutoTest
{
    auto i = 0; //@ 错误，auto不能用于非静态成员变量
    auto const static si = 0;  //@ si -> static const int，类成员变量中静态类型无法就地初始化，所以必须要用 const 修饰
};

int arr[10] = { 0 };
auto a1 = arr;  //@ a1 -> int*
auto a2[10] = arr; //@ 错误，auto 不能用于推导数组


template <typename T>
struct Test{};

Test<int> t;
Test<auto> a = t; //@ 错误，auto 不能用于模板参数推导
```

在 C++14 里，auto 还新增了一个应用场合，就是能够推导函数返回值：

```
auto get_vec()
{
	return std::vector<int>{1,2,3,4};
}
```

auto 使用场景：

- 遍历 STL 容器
- 类型未定变量声明

## decltype

decltype 用在编译时推导出表达式的类型，并且不会真正计算表达式的值，decltype 能够保持变量的引用和 CV 特性，这一点与 auto不同。

```
decltype(exp)
```

推导规则：

- 如果 exp 是标识符，类访问表达式，decltype(exp) 与 exp 的类型一致，并且保留引用和 CV 属性，这一点与 auto 不同
- 如果 exp 是函数调用，decltype(exp) 和返回值得类型一致
- 其他情况，如果 exp 是一个左值引用， decltype(exp) 是 exp 的左值引用，否则与 exp 类型一致
- 可以附加上 const、volatile、*、& 这样的类型修饰符，得到新的类型  

```
//@ 保留 cv 特性
int i = 0;
const volatile int& cvr = i;
decltype(cvr) a = i;  //@ a -> const volatile int &

//@ 推导函数返回值
const int func_int_r(void);		//@ 返回纯右值
const int& func_int_l(void);	//@ 返回左值
const int&& func_int_x(void);	//@ 返回 x 值(右值引用本身是一个 xvalue)

int main()
{	
	int x = 0;
	decltype(func_int_r()) a;		//@ a -> int,去掉了 CV 特性
	decltype(func_int_l()) b = x;	//@ b -> const int&
	decltype(func_int_x()) c = 0;	//@ c -> const int&&
    return 0;
}

//@ 其它情况
const int x = 1;
int y = 2;
const int* p = &x;

decltype(x) a = 0;			//@ a->const int
decltype((x)) b = 0;		//@ b->const int&
decltype(x + y) c = 1;		//@ c->int
decltype(y += x) d = y;		//@ d->int&
decltype(y = 3) e = y;		//@ e->int&
decltype(*p) f = 0;			//@ f->const int&
```

这里需要注意的是：

- `(表达式)` 的类型为左值引用
- `m+n` 的类型是右值
- `m+=n` 的类型是左值引用

decltype 应用：

完全可以把 decltype 看成是一个真正的类型名，用在变量声明、函数参数 / 返回值、模板参数等任何类型能出现的地方，只不过这个类型是在编译阶段通过表达式“计算”得到的。  

```
//@ 模板中的类型推导
template<typename T, typename U>
void func(T t, U u)
{
	decltype(t*u) tu = t * u;	//@ t*u 是 int 类型，类型提升了
	std::cout << tu << std::endl;
}

int main()
{
	short a = 1;
	char c = 3;
	func(a, c);

	return 0;
}

```

## 尾返回类型推导

返回值类型后置：返回值类型后置一般用于返回值依赖于参数类型而导致难以确定返回值的具体类型。

```
template<typename T, typename U>
auto func(T t, U u)->decltype(t + u)
{
	return t + u;
}
```

从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：

```
template<typename T, typename U>
auto add3(T x, U y){
    return x + y;
}
```

## decltype(auto)

decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 decltype 的参数表达式。

```
int x = 0;

decltype(auto) x1 = (x); //@ x1->int&,因为 (expr) 是引用类型
decltype(auto) x2 = &x; //@ x2->int*
decltype(auto) x3 = x1; //@ x1->int&

auto a = (x);  //@ a -> int，auto 推导只是值推导
decltype((x)) a = x;  //@ a -> int&，decltype 推导是完整类型推导
```

# 范围 for

```
std::vector<int> vec{ 1,2,3 };

for (auto v : vec)  //@ 对 v 的修改不会同步到 vec  
    //@ do something

for(auto &v : vec) //@ 对 v 的修改会同步到 vec 
	//@ do something

for(const auto& v : vec) //@ 对 v 不执行拷贝，并且不支持对 v 修改
	//@ do something
```

使用注意事项：

- `:` 后面的表达式只执行一次
- 防止在范围 for 中迭代器失效

```
std::vector<int> get_vec()
{
	std::cout << "get_vec()" << std::endl;
	return { 1,2,3 };
}
for (auto const v : get_vec()) //@ get_vec 函数只会执行一次，不会在每次遍历时反复执行
	std::cout << v << " ";

//@ 改变容器将会导致迭代器失效
std::vector<int> vec{ 1,2,3 };
for (auto const v : vec)
{
	std::cout << v << " ";
	vec.push_back(0);  //@ 迭代器失效
}
```

范围 for 的原理：

- 如容器是一个普通的数组对象，那么 begin 将是数组的首地址，end 将是数组首地址加上容器长度
- 如果容器是一个类对象，那么范围 for 将试图通过查找类的 begin() 和 end() 函数来定位 begin 和 end
- 否则范围 for 将使用全局的 begin() 和 end() 函数来定位 begin 和 end

自定义类型如果想使用范围 for ，需要分别实现 begin() 和 end() 函数。

# 模板

模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。

## 外部模板

模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板的实例化。

为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化：

```
template class std::vector<bool>;          //@ 强行实例化

extern template class std::vector<double>; //@ 不在该当前编译文件中实例化模板
```

## 类型别名模板

模板是用来产生类型的。在传统 C++ 中，typedef  可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：

```
template <typename T>
typedef std::map<std::string, T> map_t;  //@ 错误
```

但是 C++ 11 中，使用 using 声明可以实现这个目的：

```
template <typename T>
using map_t = std::map<std::string, T> ;
```

typedef 对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。使用 using 声明的形式则容易理解：

```
typedef int (*process)(void *);

using NewProcess = int(*)(void *);
```

## 默认模板参数

在 C++11 中提供了一种便利，可以指定模板的默认参数：

```
template<typename T = int, typename U = int>
auto add(T x, U y) -> decltype(x+y) {
    return x+y;
}
```

## 函数模板的默认参数

C++ 11 之前允许类模板有默认参数，但是不允许函数模板有默认参数：

```
template <typename T,typename U = int,U N = 0>
struct Foo {};


template <typename T = int>  //@ C++ 11 之前不允许
void func()
{}
```

但是 C++ 11 中解除了上述对于函数模板默认参数的限制，在 C++ 11 中可以直接调用：

```
func();   //@ 如同一个普通函数
```

函数模板的默认参数不需要在数列表中从右向左书写，而是可以出现在任意位置：

```
template <typename X,typename T = int, typename U>
T func(X val1,U val2)
{
	return static_cast<int>(val1 + val2);
}
```

## 变长参数模板

C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。

```
template<typename... Ts> 
class Magic;
```

模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如：

```
class Magic<int, std::vector<int>, std::map<std::string, std::vector<int>>> darkMagic;

class Magic<> nothing;
```

如果不希望产生的模板参数个数为0，可以手动的定义至少一个模板参数：

```
template<typename Require, typename... Args> 
class Magic;
```

可以使用 `sizeof...` 来计算参数的个数：

```
template<typename... Ts>
void magic(Ts... args) {
    std::cout << sizeof...(args) << std::endl;
}
```

对参数进行解包的方法：

递归模板函数：递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的。

```
template<typename T>
void print(T value) 
{
	std::cout << value << std::endl;
}

template<typename T, typename... Args>
void print(T value, Args... args)
{
	std::cout << value << std::endl;
	print(args...);
}

int main() 
{
	print(1, 2, "123", 1.1);
	return 0;
}
```

递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。

初始化列表展开：

```
template<typename T, typename... Args>
auto print(T value, Args... args)
{
	std::cout << value << std::endl;
	std::initializer_list<T>{([&args] 
	{
		std::cout << args << std::endl;
	}(), value)...};
}
```

变参模板展开：C++17 中增加了变参模板展开的支持。

```
template<typename T, typename... Args>
void print(T t, Args... args) 
{
	std::cout << t << std::endl;
	if constexpr (sizeof...(args) > 0) 
		print(t...);
}
```

## 非类型模板参数推导

还有一种常见模板参数形式可以让不同字面量成为模板参数，即非类型模板参数：

```
template <typename T, int BufSize>
class buffer_t {
public:
    T& alloc();
    void free(T& item);
private:
    T data[BufSize];
}

buffer_t<int, 100> buf; // 100 作为模板参数
```



# 右值和移动

# 模板的改进

# 控制流



# 



# 面向对象

## 聚合类

聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：

- 所有成员都是 public 的
- 没有定义任何构造函数
- 没有类内初始化
- 没有基类，也没用 virtual 函数

```
struct Data 
{
　　int ival;
　　string s;
};
```

可以提供一个花括号括起来的成员初始化列表，并用它初始化聚合类的数据成员，初始值的顺序必须与声明的顺序一致：

```
Data val1={"Anna",1024"};
```

与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。

