# 了解SQL  

- 数据库（database） 保存有组织的数据的容器（通常是一个文件或一组文件）
- 表（table） 某种特定类型数据的结构化清单  
- 模式（schema） 关于数据库和表的布局及特性的信息  
- 列（column） 表中的一个字段。所有表都是由一个或多个列组成的
- 数据类型（datatype） 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据   
- 行（row） 表中的一个记录  
- 主键（primary key）一列（或一组列），其值能够唯一区分表中每个行   
  - 任意两行都不具有相同的主键值  
  - 每个行都必须具有一个主键值（主键列不允许NULL值）  

SQL 是结构化查询语言（Structured Query Language）的缩写。 SQL是一种专门用来与数据库通信的语言。  

# 使用MySQL  

选择数据库：

```
USE <数据库名称>
```

查看可用数据库的一个列表：

```
SHOW DATABASE;
```

获得一个数据库内的表的列表：

```
SHOW TABLES;
```

显示表列：

```
SHOW COLUMNS FROM <表名称>;
DESCRIBE <表名称>;
```

显示服务器错误或警告消息：

```
SHOW ERRORS;
SHOW WARNINGS;
```

# 检索数据

检索单个列：

```
SELECT <列名称> FROM <表名称>;
```

检索多个列：

```
SELECT <列名称1>,<列名称2>,<列名称3>,... FROM <表名称>;
```

检索所有列：

```
SELECT * FROM <表名称>;
```

**一般，除非你确实需要表中的每个列，否则最好别使用*通配符。虽然使用通配符可能会使你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。**  

检索不同的行：

```
SELECT DISTINCT <列名称> FROM <表名称>;
```

**不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT column1,column2，除非指定的两个列都不同，否则所有行都将被检索出来。    **

限制结果：

```
SELECT <列名称> FROM <表名称> LIMIT <限制行数>;
```

返回不超过"限制数量"的行数。

```
SELECT <列名称> FROM <表名称> LIMIT <偏移行数>,<限制行数>;
SELECT <列名称> FROM <表名称> LIMIT <限制行数> OFFSET <偏移行数>;
```

**LIMIT中指定要检索的行数为检索的最大行数。如果没有足够的行， MySQL将只返回它能返回的那么多行。**

使用完全限定的表名：

```
SELECT <表名称>.<列名称> FROM <表名称>;
SELECT <表名称>.<列名称> FROM <库名称>.<表名称>;
```

# 排序检索数据

**关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。  **

```
SELECT <查询列名称> FROM <表名称> ORDER BY <排序列名称>;
```

按多个列排序：

```
SELECT <查询列名称> FROM <表名称> ORDER BY <排序列名称1>,<排序列名称2>;
```

**排序完全按所规定的顺序进行。**

指定排序方向：

降序排列使用 DESC，升序排列使用 ASC，默认是升序排列。

```
SELECT <查询列名称> FROM <表名称> ORDER BY <排序列名称> DESC;
```

多个列排序：

```
SELECT <查询列名称> FROM <表名称> ORDER BY <排序列名称1> <序列形式>,<排序列名称2> <序列形式>;
```

如果是升序上面的"序列形式"可以省略，但是如果是降序则必须指明。

# 过滤数据

```
SELECT <列名称> FROM <表名称> WHERE <条件>;
```

WHERE子句操作符：

![](./img/where_condition.png)

**MySQL在执行匹配时默认不区分大小写。**

范围值检查：

```
SELECT <列名称> FROM <表名称> WHERE <条件列名称> BETWEEN <value_samll> AND <value_big>;
```

**在使用BETWEEN时，必须指定两个值即所需范围的低端值和高端值。这两个值必须用AND关键字分隔。 BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。**  

检查具有NULL值的列：

````
SELECT <列名称> FROM <表名称> WHERE <条件列名称> IS NULL;
````

**NULL 无值（no value），它与字段包含0、空字符串或仅仅包含空格不同。**  

**操作符（operator） 用来联结或改变WHERE子句中的子句的关键字。也称为逻辑操作符（ logical operator） 。 ** 

AND操作符：

```
SELECT <列名称> FROM <表名称> WHERE <条件1> AND <条件2>;
```

OR操作符：

```
SELECT <列名称> FROM <表名称> WHERE <条件1> OR <条件2>;
```

IN操作符：

```
SELECT <列名称> FROM <表名称> WHERE <列名称> IN (value1,value2,...);
```

**IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。 IN取合法值的由逗号分隔的清单，全都括在圆括号中。**

- IN操作符一般比OR操作符清单执行更快  
- 在使用长的合法选项清单时， IN操作符的语法更清楚且更直观  
- 在使用IN时，计算的次序更容易管理（因为使用的操作符更少）  
- IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句  

NOT操作符：

```
SELECT <列名称> FROM <表名称> WHERE NOT <条件>;
```

**WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。**  

# 用通配符进行过滤  

LIKE操作符：

- 通配符（wildcard） 用来匹配值的一部分的特殊字符
  - 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符
  - 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的  
  - 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据  
- 搜索模式（search pattern）由字面值、通配符或两者组合构成的搜索条件

百分号（ %）通配符：

```
SELECT <列名称> FROM <表名称> WHERE LIKE <"prefix%suffix">;
```

**%表示任何字符出现任意次数。**

**根据MySQL的配置方式，搜索可以是区分大小写的。  **

下划线 （ _）通配符：

```
SELECT <列名称> FROM <表名称> WHERE LIKE <"prefix_suffix">;
```

**下划线总是匹配一个字符，不能多也不能少  。  **

MySQL中的匹配不区分大小写。为区分大小写，可使用BINARY关键字：

```
SELECT <列名称>  FROM <表名称> WHERE <表名称> LIKE BINARY <表达式>;
```



# 使用MySQL正则表达式  

基本字符匹配：

```
SELECT <列名称>  FROM <表名称> WHERE <表名称> REGEXP <'正则表达式'>;
```

进行OR匹配：

```
SELECT <列名称>  FROM <表名称> WHERE <表名称> REGEXP <'表达式1 | 表达式2 | 表达式3...''>;
```

匹配几个字符之一：

```
SELECT <列名称>  FROM <表名称> WHERE <表名称> REGEXP <'[字符集]'>;
```

匹配范围：

```
SELECT <列名称>  FROM <表名称> WHERE <表名称> REGEXP <'[a-z0-9]'>;
```

匹配特殊字符：

```
SELECT <列名称>  FROM <表名称> WHERE <表名称> REGEXP <'\\特殊字符'>;
```

空白元字符：

![](./img/white_space_character.png)

匹配字符类：

![](./img/character_class.png)

匹配多个实例：

![](./img/repeat_character.png)

定位符：

![](./img/locator.png)

**"^"有两种用法。在集合中用它来否定该集合，否则，用来指串的开始处。**

**LIKE 和 REGEXP 的不同在于， LIKE匹配整个串而REGEXP匹配子串。**  

# 创建计算字段  

字段（field） 基本上与列（ column） 的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。  

拼接（concatenate） 将值联结到一起构成单个值。  

拼接字段：

```
SELECT CONCAT(<字段1>,<字段2>,<字段3>,...) FROM <表名称>;
```

使用别名：

```
SELECT CONCAT(<字段1>,<字段2>,<字段3>,...) AS <别名> FROM <表名称>;
```

执行算术计算：

![](./img/arithmetic_operator.png)

# 使用数据处理函数  

大多数SQL实现支持以下类型的函数：

- 用于处理文本串的文本函数  
- 用于在数值数据上进行算术操作的数值函数  
- 用于处理日期和时间值并从这些值中提取特定成分的日期和时间函数  
- 返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的系统函数  

文本处理函数：

![](./img/text_function.png)

日期和时间处理函数：

![](./img/date_time_function.png)

数值处理函数：

![](./img/numeric_function.png)

# 汇总函数

聚集函数（ aggregate function） 运行在行组上，计算和返回单个值的函数。

![](./img/aggregate_function.png)  

AVG()函数：

AVG()通过对表中行数计数并计算特定列值之和，求得该列的平均值。

```
SELECT AVG(<列名称>) AS <别名> FROM <表名称>;
```

**AVG()函数忽略列值为NULL的行。  **

COUNT()函数：

COUNT()函数进行计数。 可利用COUNT()确定表中行的数目或符合特定条件的行的数目：

-  使用COUNT(*)对表中行的数目进行计数， 不管表列中包含的是空值（ NULL）还是非空值
- 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值    

```
SELECT COUNT(*) AS <别名> FROM <表名称>;
```

MAX()函数：

MAX()返回指定列中的最大值。 MAX()要求指定列名。

```
SELECT MAX(<列名称>) AS <别名> FROM <表名称>;
```

 **MAX()函数忽略列值为NULL的行。 **

MIN()函数：

MIN()的功能正好与MAX()功能相反，它返回指定列的最小值。与MAX()一样， MIN()要求指定列名。

```
SELECT MIN(<列名称>) AS <别名> FROM <表名称>;
```

 **MIN()函数忽略列值为NULL的行。 **

SUM()函数：

SUM()用来返回指定列值的和（总计）。  

```
SELECT SUM(<列名称>) AS <别名> FROM <表名称>;
```

 **MIN()函数忽略列值为NULL的行。 **

以上5个聚集函数都可以如下使用：  

- 对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）
- 只包含不同的值，指定DISTINCT参数    

聚集不同值：

```
SELECT <聚集函数>(<DISTINCT 列名称>) AS <别名> FROM <表名称>;
```

**DISTINCT 不能用于COUNT(*)，因此不允许使用COUNT（ DISTINCT），否则会产生错误。**

组合聚集函数：

```
SELECT <聚集函数1>(<列名称1>) AS <别名1>, 
	   <聚集函数2>(<列名称2>) AS <别名2>, 
	   <聚集函数3>(<列名称3>) AS <别名3>，
	   ...
FROM <表名称>;
```

# 分组数据

创建分组：

```
SELECT <列名称>,COUNT(*) AS <别名> FROM <表名称> GROUP BY <列名称>;
```

GROUP BY 子句的一些规定：

- GROUP BY 子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制
- 如果在 GROUP BY 子句中嵌套了分组，数据将在最后规定的分组上进行汇总
- GROUP BY 子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在 SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式，不能使用别名
- 除聚集计算语句外， SELECT 语句中的每个列都必须在 GROUP BY 子句中给出
- 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组
- GROUP BY 子句必须出现在 WHERE 子句之后， ORDER BY 子句之前         

使用 WITH ROLLUP 关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值。

过滤分组：

HAVING 非常类似于 WHERE。事实上，目前为止所学过的所有类型的 WHERE 子句都可以用 HAVING 来替代。唯一的差别是 WHERE 过滤行，而 HAVING 过滤分组。  

分组和排序：

![](./img/group_order.png)

SELECT子句顺序：

![](./img/clause.png)

# 使用子查询  

子查询（ subquery）即嵌套在其他查询中的查询。子查询总是从内向外处理。    

```
SELECT <列名称> FROM <表名称> WHERE <查询列名称> IN(SELECT <查询列名称> FROM <表名称> <条件>);
```

- 在WHERE子句中使用子查询，应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列
- 虽然子查询一般与IN操作符结合使用，但也可以用于测试等于（=）、不等于（<>）等  

作为计算字段使用子查询：

使用子查询的另一方法是创建计算字段。  

```
SELECT <列名称>,<列名称>,(SELECT COUNT(*) FROM <表名称1> WHERE <表名称1>.<列名称> = <表名称2>.<列名称>) AS <别名> FROM <表名称2> ORDER BY <列名称>;
```

# 联结  

外键（foreign key） 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。  

创建联结：

```
SELECT <表名称1>.<列名称1> ,<表名称2>.<列名称2>  FROM <表名称1>,<表名称2> <条件>;
```

笛卡儿积（cartesian product） 由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。  

内部联结：

等值联结（equijoin）基于两个表之间的相等测试。这种联结也称为内部联结。  

```
SELECT <表名称1>.<列名称1>,<表名称2>.<列名称2> FROM <表名称1> INNER JOIN <表名称2> ON <条件>;
```

**两个表之间的关系是FROM子句的组成部分，以INNERJOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。**  

**ANSI SQL规范首选INNER JOIN语法。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。** 

# 联结多个表  

SQL对一条SELECT语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系。  

```
SELECT <表名称1>.<列名称1>,<表名称2>.<列名称2>，<表名称3>.<列名称3> FROM <表名称1>,<表名称2>,<表名称3> WHERE <条件1> AND <条件2> AND...;
```

**MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。**  

# 创建高级联结  

使用表别名：

```
SELECT <列名称1>,<列名称2>,<列名称3>... FROM <表名称1> AS <别名1>,<表名称2> AS <别名2>,<表名称3> AS <别名3> WHERE <条件>;
```

**表别名不仅能用于WHERE子句，它还可以用于SELECT的列表、 ORDER BY子句以及语句的其他部分。**

自联结：

```
SELECT <别名1>.<列名称1>,<别名2>.<列名称2> FROM <表名称> AS <别名1>,<表名称> AS <别名2> <条件>;
```

此查询中需要的两个表实际上是相同的表，但是引用具有二义性，为解决此问题，使用了表别名。  

使用子查询可以达到同样的目的：

```
SELECT <列名称1>,<列名称2>,<列名称3>... FROM <表名称> WHERE <列名称> = (SELECT <列名称> FROM <表名称> <条件>);
```

**自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。应该试一
下两种方法，以确定哪一种的性能更好。**

自然联结：

无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。  标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。 自然联结排除多次出现，使每个列只返回一次。  

```
SELECT <别名1>.*,<别名2>.<列名称>,<别名3>.<列名称> FROM <表名称1> AS <别名1>,<表名称2> AS <别名2>,<表名称3> AS <别名3> WHERE <条件>;
```

外部联结：

联结包含了那些在相关表中没有关联行的行。这种类型的联结称为外部联结。  

```
SELECT <表名称1>.<列名称1>,<表名称2>.<列名称2> FROM <表名称1> LEFT/RIGHT OUTER JOIN <表名称2> ON <条件>;
```

**与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（ RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。**   

使用带聚集函数的联结：

```
SELECT <表名称1>.<列名称1>,<表名称2>.<列名称2> ,COUNT(<表名称2>.<列名称3>) AS <表名称1> FROM <表名称2> LEFT OUTER JOIN <条件>;
```

# 组合查询  

















































