# OSI 模型

OSI（Open System Interconnection Reference Model）：

![](./img/osi.png)



# TCP/IP 模型

![](./img/tcp_ip.png)

# 键⼊⽹址到⽹⻚显示过程

## 解析 URL  

⾸先浏览器做的第⼀步⼯作就是要对 URL 进⾏解析，从⽽⽣成发送给 Web 服务器的请求信息。  

![](./img/parse_url.png)

当没有路径名时，就代表访问根⽬录下事先设置的默认⽂件，也就是 /index.html 或者 /default.html 这些⽂件，这样就不会发⽣混乱了。  

## ⽣产 HTTP 请求信息  

对 URL 进⾏解析之后，浏览器确定了 Web 服务器和⽂件名，接下来就是根据这些信息来⽣成 HTTP 请求消息了。  

![](./img/gen_http.png)

## DNS  

通过浏览器解析 URL 并⽣成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。但在发送之前，还有⼀项⼯作需要完成，那就是查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。  

### 域名的层级关系  

DNS 中的域名都是⽤句点来分隔的，⽐如 www.server.com ，这⾥的句点代表了不同层次之间的界限。在域名中， 越靠右的位置表示其层级越⾼。  

所以域名的层级关系类似⼀个树状结构：

- 根 DNS 服务器
- 顶级域 DNS 服务器（com）
- 权威 DNS 服务器（server.com）  

![](./img/domain_tree.png)

根域的 DNS 服务器信息保存在互联⽹中所有的 DNS 服务器中。这样⼀来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。因此，客户端只要能够找到任意⼀台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再⼀路顺藤摸⽠找到位于下层的某台⽬标 DNS 服务器。  

### 域名解析的⼯作流程  

- 客户端⾸先会发出⼀个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）
- 本地域名服务器收到客户端的请求后，如果缓存⾥的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器： “⽼⼤， 能告诉我 www.server.com 的 IP 地址吗？ ” 根域名服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路
- 根 DNS 收到来⾃本地 DNS 的请求后，发现后置是 .com，说： “www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧 ”  
- 本地 DNS 收到顶级域名服务器的地址后，发起请求问“⽼⼆， 你能告诉我 www.server.com 的 IP 地址吗”  
- 顶级域名服务器说： “我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”  
- 本地 DNS 于是转向问权威 DNS 服务器： “⽼三， www.server.com对应的IP是啥呀？ ” server.com 的权威DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主
- 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS  
- 本地 DNS 再将 IP 地址返回客户端，客户端和⽬标建⽴连接   

![](./img/dns.png)

DNS 域名解析的过程蛮有意思的，整个过程就和我们⽇常⽣活中找⼈问路的过程类似， 只指路不带路。  

## 协议栈  

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输⼯作交给操作系统中的协议栈。协议栈的内部分为⼏个部分，分别承担不同的⼯作。上下关系是有⼀定的规则的，上⾯的部分会向下⾯的部分委托⼯作，下⾯的部分收到委托的⼯作并执⾏。  

![](./img/procotol_statck.png)

应⽤程序（浏览器）通过调⽤ Socket 库，来委托协议栈⼯作。协议栈的上半部分有两块，分别是负责收发数据的TCP 和 UDP 协议，它们两会接受应⽤层的委托执⾏收发数据的操作。协议栈的下⾯⼀半是⽤ IP 协议控制⽹络包收发操作，在互联⽹上传数据时，数据会被切分成⼀块块的⽹络包，⽽将⽹络包发送给对⽅的操作就是由 IP 负责的。  

此外 IP 中还包括 ICMP 协议和 ARP 协议：

- ICMP ⽤于告知⽹络包传送过程中产⽣的错误以及各种控制信息
- ARP ⽤于根据 IP 地址查询相应的以太⽹ MAC 地址

IP 下⾯的⽹卡驱动程序负责控制⽹卡硬件，⽽最下⾯的⽹卡则负责完成实际的收发操作，也就是对⽹线中的信号执⾏发送和接收操作。  

### 可靠传输 —— TCP  

HTTP 是基于 TCP 协议传输的。

#### TCP 包头格式  

![](./img/tcp.png)

⾸先， 源端⼝号和⽬标端⼝号是不可少的，如果没有这两个端⼝号，数据就不知道应该发给哪个应⽤。  

包的序号，这个是为了解决包乱序的问题。  

确认号⽬的是确认发出去对⽅是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决不丢包的问题。  

接下来还有⼀些状态位。例如 SYN 是发起⼀个连接， ACK 是回复， RST 是重新连接， FIN 是结束连接等。 TCP 是⾯向连接的，因⽽双⽅要维护连接的状态，这些带状态位的包的发送，会引起双⽅的状态变更。  

还有⼀个重要的就是窗⼝⼤⼩。 TCP 要做流量控制，通信双⽅各声明⼀个窗⼝（缓存⼤⼩），标识⾃⼰当前能够的处理能⼒。  

除了做流量控制以外， TCP还会做拥塞控制，对于真正的通路堵⻋不堵⻋，它⽆能为⼒，唯⼀能做的就是控制⾃⼰，也即控制发送的速度。  

#### 三次握⼿建⽴连接  

在 HTTP 传输数据之前，⾸先需要 TCP 建⽴连接， TCP 连接的建⽴，通常称为三次握⼿。这个所谓的连接，只是双⽅计算机⾥维护⼀个状态机。

![](./img/tcp_3_handshakes.png)

- ⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态
- 然后客户端主动发起连接 SYN ，之后处于 SYN-SENT 状态
- 服务端收到发起的连接，返回 SYN ，并且 ACK 客户端的 SYN ，之后处于 SYN-RCVD 状态
- 客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK ，之后处于 ESTABLISHED 状态，因为它⼀发⼀收成功了
- 服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也⼀发⼀收了

所以三次握⼿⽬的是保证双⽅都有发送和接收的能⼒。  

在 Linux 可以通过 netstat -napt 命令查看 TCP 的连接状态：

![](./img/netstat.png)

    #### TCP 分割数据  

如果 HTTP 请求消息⽐较⻓，超过了 MSS 的⻓度，这时 TCP 就需要把 HTTP 的数据拆解成⼀块块的数据发送，⽽不是⼀次性发送所有数据。  

![](./img/mtu_mss.png)

- MTU ：⼀个⽹络包的最⼤⻓度，以太⽹中⼀般为 1500 字节  
- MSS ：除去 IP 和 TCP 头部之后，⼀个⽹络包所能容纳的 TCP 数据的最⼤⻓度  

数据会被以 MSS 的⻓度为单位进⾏拆分，拆分出来的每⼀块数据都会被放进单独的⽹络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。  

![](./img/package.png)

#### TCP 报⽂⽣成  

TCP 协议⾥⾯会有两个端⼝，⼀个是浏览器监听的端⼝（通常是随机⽣成的），⼀个是 Web 服务器监听的端⼝（HTTP 默认端⼝号是 80 ， HTTPS 默认端⼝号是 443 ）。  

在双⽅建⽴了连接后， TCP 报⽂中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报⽂之后，就需交给下⾯的⽹络层处理。⾄此，⽹络包的报⽂如下图。  

![](./img/tcp_package.png)

### 远程定位 —— IP  

TCP 模块在执⾏连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成⽹络包发送给通信对象。  

#### IP 包头格式  

![](./img/ip_package.png)

在 IP 协议⾥⾯需要有源地址 IP 和 ⽬标地址 IP：

- 源地址IP，即是客户端输出的 IP 地址
- ⽬标地址，即通过 DNS 域名解析得到的 Web 服务器 IP

因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 06 （⼗六进制），表示协议为 TCP。  

当存在多个⽹卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块⽹卡中判断应该使⽤哪个⼀块⽹卡来发送包。这个时候就需要根据路由表规则，来判断哪⼀个⽹卡作为源地址 IP。在 Linux 操作系统，我们可以使⽤ route -n 命令查看当前系统的路由表。  

![](./img/route.png)

举个例⼦，根据上⾯的路由表，我们假设 Web 服务器的⽬标地址是 192.168.10.200 。  

![](./img/ip_judgment.png)

- ⾸先先和第⼀条⽬的⼦⽹掩码（Genmask ）进⾏ 与运算，得到结果为 192.168.10.0 ，但是第⼀个条⽬的 Destination 是 192.168.3.0 ，两者不⼀致所以匹配失败  
- 再与第⼆条⽬的⼦⽹掩码进⾏ 与运算，得到的结果为 192.168.10.0 ，与第⼆条⽬的 Destination 192.168.10.0 匹配成功，所以将使⽤ eth1 ⽹卡的 IP 地址作为 IP 包头的源地址  

那么假设 Web 服务器的⽬标地址是 10.100.20.100 ，那么依然依照上⾯的路由表规则判断，判断后的结果是和第三条⽬匹配。第三条⽬⽐较特殊，它⽬标地址和⼦⽹掩码都是 0.0.0.0 ，这表示默认⽹关，如果其他所有条⽬都⽆法匹配，就会⾃动匹配这⼀⾏。并且后续就把包发给路由器， Gateway 即是路由器的 IP 地址。  

#### IP 报⽂⽣成  

⽹络包的报⽂如下图：

![](./img/ip_package2.png)

### 两点传输 —— MAC  

⽣成了 IP 头部之后，接下来⽹络包还需要在 IP 头部的前⾯加上 MAC 头部。  

#### MAC 包头格式  

MAC 头部是以太⽹使⽤的头部，它包含了接收⽅和发送⽅的 MAC 地址等信息。  

![](./img/mac_header.png)

在 MAC 包头⾥需要发送⽅ MAC 地址和接收⽅⽬标 MAC 地址，⽤于两点之间的传输。
⼀般在 TCP/IP 通信⾥， MAC 包头的协议类型只使⽤：

- 0800 ： IP 协议
- 0806 ： ARP 协议  

#### MAC 发送⽅和接收⽅如何确认  

发送⽅的 MAC 地址获取就⽐较简单了， MAC 地址是在⽹卡⽣产时写⼊到 ROM ⾥的，只要将这个值读取出来写⼊到 MAC 头部就可以了。

接收⽅的 MAC 地址就有点复杂了，只要告诉以太⽹对⽅的 MAC 的地址，以太⽹就会帮我们把包发送过去，那么很显然这⾥应该填写对⽅的 MAC 地址。  

此时就需要 ARP 协议帮我们找到路由器的 MAC 地址。ARP 协议会在以太⽹中以⼴播的形式，对以太⽹所有的设备喊出： “这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。然后就会有⼈回答： “这个 IP 地址是我的，我的 MAC 地址是 XXXX”。如果对⽅和⾃⼰处于同⼀个⼦⽹中，那么通过上⾯的操作就可以得到对⽅的 MAC 地址。然后，我们将这个 MAC 地址写⼊ MAC 头部， MAC 头部就完成了。    

![](./img/arp.png)

在后续操作系统会把本次查询结果放到⼀块叫做 ARP 缓存的内存空间留着以后⽤，不过缓存的时间就⼏分钟。  

也就是说，在发包时：  

- 先查询 ARP 缓存，如果其中已经保存了对⽅的 MAC 地址，就不需要发送 ARP 查询，直接使⽤ ARP 缓存中的地址
- ⽽当 ARP 缓存中不存在对⽅ MAC 地址时，则发送 ARP ⼴播查询  

查看 ARP 缓存内容：

在 Linux 系统中，我们可以使⽤ arp -a 命令来查看 ARP 缓存的内容：

![](./img/arp_a.png)

#### MAC 报⽂⽣成  

![](./img/mac_package.png)

### 出⼝ —— ⽹卡  

