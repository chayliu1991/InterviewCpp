# OSI 模型

OSI（Open System Interconnection Reference Model）：

![](./img/osi.png)



# TCP/IP 模型

![](./img/tcp_ip.png)

# 键⼊⽹址到⽹⻚显示过程

## 解析 URL  

⾸先浏览器做的第⼀步⼯作就是要对 URL 进⾏解析，从⽽⽣成发送给 Web 服务器的请求信息。  

![](./img/parse_url.png)

当没有路径名时，就代表访问根⽬录下事先设置的默认⽂件，也就是 /index.html 或者 /default.html 这些⽂件，这样就不会发⽣混乱了。  

## ⽣产 HTTP 请求信息  

对 URL 进⾏解析之后，浏览器确定了 Web 服务器和⽂件名，接下来就是根据这些信息来⽣成 HTTP 请求消息了。  

![](./img/gen_http.png)

## DNS  

通过浏览器解析 URL 并⽣成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。但在发送之前，还有⼀项⼯作需要完成，那就是查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。  

### 域名的层级关系  

DNS 中的域名都是⽤句点来分隔的，⽐如 www.server.com ，这⾥的句点代表了不同层次之间的界限。在域名中， 越靠右的位置表示其层级越⾼。  

所以域名的层级关系类似⼀个树状结构：

- 根 DNS 服务器
- 顶级域 DNS 服务器（com）
- 权威 DNS 服务器（server.com）  

![](./img/domain_tree.png)

根域的 DNS 服务器信息保存在互联⽹中所有的 DNS 服务器中。这样⼀来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。因此，客户端只要能够找到任意⼀台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再⼀路顺藤摸⽠找到位于下层的某台⽬标 DNS 服务器。  

### 域名解析的⼯作流程  

- 客户端⾸先会发出⼀个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）
- 本地域名服务器收到客户端的请求后，如果缓存⾥的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器： “⽼⼤， 能告诉我 www.server.com 的 IP 地址吗？ ” 根域名服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路
- 根 DNS 收到来⾃本地 DNS 的请求后，发现后置是 .com，说： “www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧 ”  
- 本地 DNS 收到顶级域名服务器的地址后，发起请求问“⽼⼆， 你能告诉我 www.server.com 的 IP 地址吗”  
- 顶级域名服务器说： “我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”  
- 本地 DNS 于是转向问权威 DNS 服务器： “⽼三， www.server.com对应的IP是啥呀？ ” server.com 的权威DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主
- 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS  
- 本地 DNS 再将 IP 地址返回客户端，客户端和⽬标建⽴连接   

![](./img/dns.png)

DNS 域名解析的过程蛮有意思的，整个过程就和我们⽇常⽣活中找⼈问路的过程类似， 只指路不带路。  

## 协议栈  

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输⼯作交给操作系统中的协议栈。协议栈的内部分为⼏个部分，分别承担不同的⼯作。上下关系是有⼀定的规则的，上⾯的部分会向下⾯的部分委托⼯作，下⾯的部分收到委托的⼯作并执⾏。  

![](./img/procotol_statck.png)

应⽤程序（浏览器）通过调⽤ Socket 库，来委托协议栈⼯作。协议栈的上半部分有两块，分别是负责收发数据的TCP 和 UDP 协议，它们两会接受应⽤层的委托执⾏收发数据的操作。协议栈的下⾯⼀半是⽤ IP 协议控制⽹络包收发操作，在互联⽹上传数据时，数据会被切分成⼀块块的⽹络包，⽽将⽹络包发送给对⽅的操作就是由 IP 负责的。  

此外 IP 中还包括 ICMP 协议和 ARP 协议：

- ICMP ⽤于告知⽹络包传送过程中产⽣的错误以及各种控制信息
- ARP ⽤于根据 IP 地址查询相应的以太⽹ MAC 地址

IP 下⾯的⽹卡驱动程序负责控制⽹卡硬件，⽽最下⾯的⽹卡则负责完成实际的收发操作，也就是对⽹线中的信号执⾏发送和接收操作。  

### 可靠传输 —— TCP  

HTTP 是基于 TCP 协议传输的。

#### TCP 包头格式  

![](./img/tcp.png)

⾸先， 源端⼝号和⽬标端⼝号是不可少的，如果没有这两个端⼝号，数据就不知道应该发给哪个应⽤。  

包的序号，这个是为了解决包乱序的问题。  

确认号⽬的是确认发出去对⽅是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决不丢包的问题。  

接下来还有⼀些状态位。例如 SYN 是发起⼀个连接， ACK 是回复， RST 是重新连接， FIN 是结束连接等。 TCP 是⾯向连接的，因⽽双⽅要维护连接的状态，这些带状态位的包的发送，会引起双⽅的状态变更。  

还有⼀个重要的就是窗⼝⼤⼩。 TCP 要做流量控制，通信双⽅各声明⼀个窗⼝（缓存⼤⼩），标识⾃⼰当前能够的处理能⼒。  

除了做流量控制以外， TCP还会做拥塞控制，对于真正的通路堵⻋不堵⻋，它⽆能为⼒，唯⼀能做的就是控制⾃⼰，也即控制发送的速度。  

#### 三次握⼿建⽴连接  

在 HTTP 传输数据之前，⾸先需要 TCP 建⽴连接， TCP 连接的建⽴，通常称为三次握⼿。这个所谓的连接，只是双⽅计算机⾥维护⼀个状态机。

![](./img/tcp_3_handshakes.png)

- ⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态
- 然后客户端主动发起连接 SYN ，之后处于 SYN-SENT 状态
- 服务端收到发起的连接，返回 SYN ，并且 ACK 客户端的 SYN ，之后处于 SYN-RCVD 状态
- 客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK ，之后处于 ESTABLISHED 状态，因为它⼀发⼀收成功了
- 服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也⼀发⼀收了

所以三次握⼿⽬的是保证双⽅都有发送和接收的能⼒。  

在 Linux 可以通过 netstat -napt 命令查看 TCP 的连接状态：

![](./img/netstat.png)

    #### TCP 分割数据  

如果 HTTP 请求消息⽐较⻓，超过了 MSS 的⻓度，这时 TCP 就需要把 HTTP 的数据拆解成⼀块块的数据发送，⽽不是⼀次性发送所有数据。  

![](./img/mtu_mss.png)

- MTU ：⼀个⽹络包的最⼤⻓度，以太⽹中⼀般为 1500 字节  
- MSS ：除去 IP 和 TCP 头部之后，⼀个⽹络包所能容纳的 TCP 数据的最⼤⻓度  

数据会被以 MSS 的⻓度为单位进⾏拆分，拆分出来的每⼀块数据都会被放进单独的⽹络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。  

![](./img/package.png)

#### TCP 报⽂⽣成  

TCP 协议⾥⾯会有两个端⼝，⼀个是浏览器监听的端⼝（通常是随机⽣成的），⼀个是 Web 服务器监听的端⼝（HTTP 默认端⼝号是 80 ， HTTPS 默认端⼝号是 443 ）。  

在双⽅建⽴了连接后， TCP 报⽂中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报⽂之后，就需交给下⾯的⽹络层处理。⾄此，⽹络包的报⽂如下图。  

![](./img/tcp_package.png)

### 远程定位 —— IP  

TCP 模块在执⾏连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成⽹络包发送给通信对象。  

#### IP 包头格式  

![](./img/ip_package.png)

在 IP 协议⾥⾯需要有源地址 IP 和 ⽬标地址 IP：

- 源地址IP，即是客户端输出的 IP 地址
- ⽬标地址，即通过 DNS 域名解析得到的 Web 服务器 IP

因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 06 （⼗六进制），表示协议为 TCP。  

当存在多个⽹卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块⽹卡中判断应该使⽤哪个⼀块⽹卡来发送包。这个时候就需要根据路由表规则，来判断哪⼀个⽹卡作为源地址 IP。在 Linux 操作系统，我们可以使⽤ route -n 命令查看当前系统的路由表。  

![](./img/route.png)

举个例⼦，根据上⾯的路由表，我们假设 Web 服务器的⽬标地址是 192.168.10.200 。  

![](./img/ip_judgment.png)

- ⾸先先和第⼀条⽬的⼦⽹掩码（Genmask ）进⾏ 与运算，得到结果为 192.168.10.0 ，但是第⼀个条⽬的 Destination 是 192.168.3.0 ，两者不⼀致所以匹配失败  
- 再与第⼆条⽬的⼦⽹掩码进⾏ 与运算，得到的结果为 192.168.10.0 ，与第⼆条⽬的 Destination 192.168.10.0 匹配成功，所以将使⽤ eth1 ⽹卡的 IP 地址作为 IP 包头的源地址  

那么假设 Web 服务器的⽬标地址是 10.100.20.100 ，那么依然依照上⾯的路由表规则判断，判断后的结果是和第三条⽬匹配。第三条⽬⽐较特殊，它⽬标地址和⼦⽹掩码都是 0.0.0.0 ，这表示默认⽹关，如果其他所有条⽬都⽆法匹配，就会⾃动匹配这⼀⾏。并且后续就把包发给路由器， Gateway 即是路由器的 IP 地址。  

#### IP 报⽂⽣成  

⽹络包的报⽂如下图：

![](./img/ip_package2.png)

### 两点传输 —— MAC  

⽣成了 IP 头部之后，接下来⽹络包还需要在 IP 头部的前⾯加上 MAC 头部。  

#### MAC 包头格式  

MAC 头部是以太⽹使⽤的头部，它包含了接收⽅和发送⽅的 MAC 地址等信息。  

![](./img/mac_header.png)

在 MAC 包头⾥需要发送⽅ MAC 地址和接收⽅⽬标 MAC 地址，⽤于两点之间的传输。
⼀般在 TCP/IP 通信⾥， MAC 包头的协议类型只使⽤：

- 0800 ： IP 协议
- 0806 ： ARP 协议  

#### MAC 发送⽅和接收⽅如何确认  

发送⽅的 MAC 地址获取就⽐较简单了， MAC 地址是在⽹卡⽣产时写⼊到 ROM ⾥的，只要将这个值读取出来写⼊到 MAC 头部就可以了。

接收⽅的 MAC 地址就有点复杂了，只要告诉以太⽹对⽅的 MAC 的地址，以太⽹就会帮我们把包发送过去，那么很显然这⾥应该填写对⽅的 MAC 地址。  

此时就需要 ARP 协议帮我们找到路由器的 MAC 地址。ARP 协议会在以太⽹中以⼴播的形式，对以太⽹所有的设备喊出： “这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。然后就会有⼈回答： “这个 IP 地址是我的，我的 MAC 地址是 XXXX”。如果对⽅和⾃⼰处于同⼀个⼦⽹中，那么通过上⾯的操作就可以得到对⽅的 MAC 地址。然后，我们将这个 MAC 地址写⼊ MAC 头部， MAC 头部就完成了。    

![](./img/arp.png)

在后续操作系统会把本次查询结果放到⼀块叫做 ARP 缓存的内存空间留着以后⽤，不过缓存的时间就⼏分钟。  

也就是说，在发包时：  

- 先查询 ARP 缓存，如果其中已经保存了对⽅的 MAC 地址，就不需要发送 ARP 查询，直接使⽤ ARP 缓存中的地址
- ⽽当 ARP 缓存中不存在对⽅ MAC 地址时，则发送 ARP ⼴播查询  

查看 ARP 缓存内容：

在 Linux 系统中，我们可以使⽤ arp -a 命令来查看 ARP 缓存的内容：

![](./img/arp_a.png)

#### MAC 报⽂⽣成  

![](./img/mac_package.png)

### 出⼝ —— ⽹卡  

⽹络包只是存放在内存中的⼀串⼆进制数字信息，没有办法直接发送给对⽅。因此，我们需要将数字信息转换为电信号，才能在⽹线上传输，也就是说，这才是真正的数据发送过程。负责执⾏这⼀操作的是⽹卡，要控制⽹卡还需要靠⽹卡驱动程序。⽹卡驱动从 IP 模块获取到包之后，会将其复制到⽹卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，在末尾加上⽤于检测错误的帧校验序列。  

![](./img/netcard.png)

- 起始帧分界符是⼀个⽤来表示包起始位置的标记  
- 末尾的 FCS （帧校验序列）⽤来检查包传输过程是否有损坏  

最后⽹卡会将包转为电信号，通过⽹线发送出去。  

### 送别者 —— 交换机  

交换机的设计是将⽹络包原样转发到⽬的地。交换机⼯作在 MAC 层，也称为⼆层⽹络设备。  

#### 交换机的包接收操作  

⾸先，电信号到达⽹线接⼝，交换机⾥的模块进⾏接收，接下来交换机⾥的模块将电信号转换为数字信号。然后通过包末尾的 FCS 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的⽹卡相同，但交换机的⼯作⽅式和⽹卡不同。  

计算机的⽹卡本身具有 MAC 地址，并通过核对收到的包的接收⽅ MAC 地址判断是不是发给⾃⼰的，如果不是发给⾃⼰的则丢弃；相对地，交换机的端⼝不核对接收⽅ MAC 地址，⽽是直接接收所有的包并存放到缓冲区中。因此，和⽹卡不同， 交换机的端⼝不具有 MAC 地址。将包存⼊缓冲区后，接下来需要查询⼀下这个包的接收⽅ MAC 地址是否已经在 MAC 地址表中有记录了。交换机的 MAC 地址表主要包含两个信息：  

- ⼀个是设备的 MAC 地址  
- 另⼀个是该设备连接在交换机的哪个端⼝上  

![](./img/switcher.png)

举个例⼦，如果收到的包的接收⽅ MAC 地址为 00-02-B3-1C-9C-F9 ，则与图中表中的第 3 ⾏匹配，根据端⼝列的信息，可知这个地址位于 3 号端⼝上，然后就可以通过交换电路将包发送到相应的端⼝了。所以， 交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端⼝。  

#### 当 MAC 地址表找不到指定的 MAC 地址会怎么样  

地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备⼀段时间没有⼯作导致地址被从地址表中删除了。这种情况下，交换机⽆法判断应该把包转发到哪个端⼝，只能将包转发到除了源端⼝之外的所有端⼝上，⽆论该设备连接在哪个端⼝上都能收到这个包。这样做不会产⽣什么问题，因为以太⽹的设计本来就是将包发送到整个⽹络的，然后只有相应的接收者才接收包，⽽其他设备则会忽略这个包。发送了包之后⽬标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写⼊ MAC 地址表，下次也就不需要把包发到所有端⼝。    

此外，如果接收⽅ MAC 地址是⼀个⼴播地址，那么交换机会将包发送到除源端⼝之外的所有端⼝。  以下两个属于⼴播地址：

- MAC 地址中的 FF:FF:FF:FF:FF:FF
- IP 地址中的 255.255.255.255  

### 出境⼤⻔ —— 路由器  

#### 路由器与交换机的区别  

⽹络包经过交换机之后，现在到达了路由器，并在此被转发到下⼀个路由器或⽬标设备。这⼀步转发的⼯作原理和交换机类似，也是通过查表判断包转发的⽬标。不过在具体的操作过程上，路由器和交换机是有区别的：

- 因为路由器是基于 IP 设计的，俗称三层⽹络设备，路由器的各个端⼝都具有 MAC 地址和 IP 地址  
- ⽽交换机是基于以太⽹设计的，俗称⼆层⽹络设备，交换机的端⼝不具有 MAC 地址  

#### 路由器基本原理  

路由器的端⼝具有 MAC 地址，因此它就能够成为以太⽹的发送⽅和接收⽅；同时还具有 IP 地址，从这个意义上来说，它和计算机的⽹卡是⼀样的。当转发包时，⾸先路由器端⼝会接收发给⾃⼰的以太⽹包，然后路由表查询转发⽬标，再由相应的端⼝作为发送⽅将以太⽹包发送出去。  

#### 路由器的包接收操作  

⾸先，电信号到达⽹线接⼝部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 FCS 进⾏错误校验。如果没问题则检查 MAC 头部中的接收⽅ MAC 地址，看看是不是发给⾃⼰的包，如果是就放到接收缓冲区中，否则就丢弃这个包。总的来说，路由器的端⼝都具有 MAC 地址，只接收与⾃身地址匹配的包，遇到不匹配的包则直接丢弃。  

#### 查询路由表确定输出端⼝  

完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。MAC 头部的作⽤就是将包送达路由器，其中的接收⽅ MAC 地址就是路由器端⼝的 MAC 地址。因此，当包到达路由器之后， MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。接下来，路由器会根据 MAC 头部后⽅的 IP 头部中的内容进⾏包的转发操作。转发操作分为⼏个阶段，⾸先是查询路由表判断转发⽬标：

